//! Utilities for `bo-tie`
//!
//! These are things that are used throughout the other crates within the `bo-tie` workspace and are
//! collected here as a common place to put them.

#![feature(generic_associated_types)]
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]

pub mod buffer;
#[cfg(feature = "cryptography")]
pub mod cryptography;
pub mod errors;

use core::fmt::{Display, Formatter, LowerHex, UpperHex};
use core::ops::{Deref, DerefMut};

/// A Bluetooth device address
///
/// This is a wrapper around a six byte array. The address shall always be represented in little
/// endian format within a `BluetoothDeviceAddress`.
///
/// # Address Types
/// A Bluetooth device address can either be a public address, a static device address, a
/// resolvable private address, or a non-resolvable private address. Bluetooth BR/EDR operation only
/// uses public addresses, but Bluetooth LE uses all four types of address.
///
/// A public address is the address is hardwired into the device. It must be retrieved from the
/// controller in order to be used by the host protocols. When using the host controller interface
/// implementation it can be acquired from the *Information Parameters* command *Read BR_ADDR*.
///
/// A static device address is generated by the host and set to a *LE* controller. It can be
/// any address so long as the random part (the least significant 46 bits) are not all either zero
/// or one. A static device address can act as an identity address (see the Security Manager
/// Protocol) but it must be saved by the host and resent upon controller reset.
///
/// A resolvable private address is *usually* a controller generated address for use in Bluetooth
/// *LE* privacy. Its main usage is for identifying a device through "resolving" an address using an
/// identity resolving key (resolving is essentially inputting the address and the identity
/// resolving key into a cypher function and seeing if the output is zero). The most common usage
/// of this is to re-establish encryption after reconnecting two LE devices.
///
/// A non-resolvable private address is a host generated address sent to the *LE* controller.
/// A non-resolvable private address is used where it is desired for the public or static device
/// address to not be known for privacy reasons, but a resolvable private address is not needed or
/// used.
///
/// # UI Representation
/// A `BluetoothDeviceAddress` can be created from the UI Representation form. This is a string
/// formatted as either twelve consecutive hexadecimals (`"XXXXXXXXXXXX"`) or separated using
/// a colon (e.g. `"XX:XX:XX:XX:XX:XX"`).
///
/// A `BluetoothDeviceAddress` can be converted into the UI representation with colons through its
/// implementation of [`Display`](core::fmt::Display). If the format with just twelve hexidecimal
/// digits is desired, it can be done using either the implementation for
/// [`LowerHex`](core::fmt::LowerHex) or [`UpperHex`](core::fmt::UpperHex).
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BluetoothDeviceAddress(pub [u8; 6]);

impl BluetoothDeviceAddress {
    /// Create a `BluetoothDeviceAddress` containing a randomly generated static device address
    #[cfg(feature = "sys-rand")]
    pub fn new_random_static() -> Self {
        use rand_core::RngCore;

        let mut a = [0u8; 6];

        loop {
            rand_core::OsRng.fill_bytes(&mut a);

            if let Ok(this) = Self::try_from_static(a) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a static device address
    ///
    /// The returned `BluetoothDeviceAddress` will contain `addr` with the marker bits for a static
    /// device address. The only way this will fail in creating a `BluetoothDeviceAddress` is if
    /// input `addr` is equal to zero or all bits between position zero through forty-five are one.
    ///
    /// # Note
    /// The marker bits for a static device address do not need to be in `addr`. This method will
    /// add the bits to the address before returning a `BluetoothDeviceAddress`.
    pub fn try_from_static(mut addr: [u8; 6]) -> Result<Self, errors::StaticDeviceError> {
        // The tag for static device address is 0b11 in the
        // two most significant bits.
        addr[5] |= 0b1100_0000;

        if addr == [0xFF; 6] {
            Err(errors::StaticDeviceError::AddressIsAllOnes)
        } else if addr == [0, 0, 0, 0, 0, 0xC0] {
            Err(errors::StaticDeviceError::AddressIsZero)
        } else {
            Ok(Self(addr))
        }
    }

    /// Create a `BluetoothDeviceAddress` containing a non-resolvable private address
    #[cfg(feature = "sys-rand")]
    pub fn new_non_resolvable() -> Self {
        use rand_core::RngCore;

        let mut a = [0u8; 6];

        loop {
            rand_core::OsRng.fill_bytes(&mut a);

            if let Ok(this) = Self::try_from_non_resolvable(a) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a non-resolvable private address
    ///
    /// The returned `BluetoothDeviceAddress` will contain `addr` with the marker bits for a
    /// non-resolvable private address. The only way this will fail in creating a
    /// `BluetoothDeviceAddress` is if input `addr` is equal to zero or all bits between position
    /// zero through forty-five are one.
    ///
    /// # Note
    /// The marker bits for a non-resolvable private address do not need to be in `addr`. This
    /// method will add the bits to the address before returning a `BluetoothDeviceAddress`.
    pub fn try_from_non_resolvable(mut addr: [u8; 6]) -> Result<Self, errors::NonResolvableError> {
        // The tag for a non resolvable private address is
        // 0b00 in the two most significant bits
        addr[5] &= 0b0011_1111;

        if [0u8; 6] == addr {
            Err(errors::NonResolvableError::AddressIsZero)
        } else if [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F] == addr {
            Err(errors::NonResolvableError::AddressIsAllOnes)
        } else {
            return Ok(Self(addr));
        }
    }

    /// Create a `BluetoothDeviceAddress` containing a resolvable private address
    ///
    /// The input is an identity resolving key (`irk`) that is used to generate the resolvable
    /// private address.
    ///
    /// # Note
    /// Most of the time this method is not needed as a resolvable private address is generated by
    /// the controller as part of the privacy process. See the Bluetooth Specification about the
    /// resolving list in the Bluetooth Low Energy Controller.
    #[cfg(all(feature = "sys-rand", feature = "cryptography"))]
    pub fn new_resolvable(irk: u128) -> Self {
        use rand_core::RngCore;

        let mut p_rand = [0u8; 3];

        loop {
            rand_core::OsRng.fill_bytes(&mut p_rand);

            if let Ok(this) = Self::try_from_resolvable(irk, p_rand) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a resolvable private address
    ///
    /// This takes an identity resolving key (`irk`) and a randomly generated three byte number
    /// (`p_rand`). The first three bytes of a resolvable address is hash value that is generated
    /// from the `irk` and `p_rand`. The last three bytes of the address is `p_rand`. Input `irk` is
    /// a cryptographic key so it must stay private within the device and only given to other
    /// devices that should be able to resolve the address.
    ///
    /// Input `p_rand` cannot be zero or all ones within bits zero to twenty-two. The last two most
    /// significant bits are used to mark the address as a resolvable private address. This method
    /// will set those bits to `0b01`.
    #[cfg(feature = "cryptography")]
    pub fn try_from_resolvable(irk: u128, mut p_rand: [u8; 3]) -> Result<Self, errors::ResolvableError> {
        // The tag for a resolvable private address is 0b01
        // in the two most significant bits.
        //
        // `p_rand[2]` will become the most significant
        // byte of the resolvable private address.
        p_rand[2] = p_rand[2] & 0b0011_1111 | 0b0100_0000;

        if [0, 0, 0x40] == p_rand {
            Err(errors::ResolvableError::PRandIsZero)
        } else if [0xFF, 0xFF, 0x7F] == p_rand {
            Err(errors::ResolvableError::PRandIsAllOnes)
        } else {
            let mut address = [0, 0, 0, p_rand[0], p_rand[1], p_rand[2]];

            address[..3].copy_from_slice(&cryptography::ah(irk, p_rand));

            Ok(Self(address))
        }
    }

    /// Try to resolve this address
    ///
    /// This method should only be called if this address is a resolvable private address.
    ///
    /// `true` is returned if `irk` was the identity resolving key used to generate this Bluetooth
    /// address. `false` is returned  if `irk` was not the correct key or this address is not a
    /// resolvable private address.
    #[cfg(feature = "cryptography")]
    pub fn resolve(&self, irk: u128) -> bool {
        let (peer_hash, p_rand) = self.0.split_at(3);

        let hash = cryptography::ah(irk, [p_rand[0], p_rand[1], p_rand[2]]);

        // Check if p_rand has the correct signature for a resolvable private address
        // (the most significant two bits must be 0b01) and the hashes match.
        (p_rand[2] & 0b1100_0000 == 0b0100_0000) && (peer_hash == hash)
    }

    /// Create a `BluetoothDeviceAddress` containing all zeros
    ///
    /// An address with all zeros is an invalid address an cannot be used for Bluetooth operations.
    /// The bytes of the returned address should be modified after it is created.
    pub fn zeroed() -> Self {
        Self([0; 6])
    }

    //=============================================
    // Error returns for implementation of TryFrom
    //=============================================
    const TOO_FEW_CHARS: &'static str = "address contains too few digits";
    const TOO_MANY_CHARS: &'static str = "address contains too many digits";
    const INVALID_CHARS: &'static str = "address contains invalid characters";
    const REPEATED_COLONS: &'static str = "multiple consecutive colons separating characters";
    const COLON_AT_FRONT: &'static str = "colon in front of the address";
    const COLON_AT_BACK: &'static str = "colon at the end of the address";
}

impl Deref for BluetoothDeviceAddress {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for BluetoothDeviceAddress {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl TryFrom<&str> for BluetoothDeviceAddress {
    type Error = &'static str;

    fn try_from(source: &str) -> Result<Self, Self::Error> {
        macro_rules! next_char {
            ($iter:expr) => {
                match $iter.next().ok_or(Self::TOO_FEW_CHARS)? {
                    ':' => match $iter.next().ok_or(Self::TOO_FEW_CHARS)? {
                        ':' => return Err(Self::REPEATED_COLONS)?,
                        c => c,
                    },
                    c => c,
                }
            };
        }

        if let ':' = source.chars().next().ok_or(Self::TOO_FEW_CHARS)? {
            return Err(Self::COLON_AT_FRONT);
        }

        if let Some(':') = source.chars().next_back() {
            return Err(Self::COLON_AT_BACK);
        }

        let mut address = [0u8; 6];

        let mut addr_chars_iter = source.chars().rev().fuse();

        for byte in address.iter_mut() {
            let mut src_buffer = [0u8; core::mem::size_of::<char>() * 2];

            let char_ms = next_char!(addr_chars_iter);

            let char_ls = next_char!(addr_chars_iter);

            let char_ms_len = char_ms.len_utf8();

            let char_ls_len = char_ls.len_utf8();

            let src_len = char_ms_len + char_ls_len;

            char_ls.encode_utf8(&mut src_buffer);

            char_ms.encode_utf8(&mut src_buffer[char_ls_len..]);

            let src = unsafe { core::str::from_utf8_unchecked(&src_buffer[..src_len]) };

            *byte = u8::from_str_radix(&src, 16).or(Err(Self::INVALID_CHARS))?;
        }

        match addr_chars_iter.next() {
            Some(_) => Err(Self::TOO_MANY_CHARS),
            None => Ok(Self(address)),
        }
    }
}

impl Display for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

impl LowerHex for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

impl UpperHex for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

/// Device Features
///
/// This is the list of the general supported device features of the BR/EDR Controller. This list
/// does not include the LE supported features nor the Extended supported features. This list can be
/// found within the Bluetooth Specification in volume 2, part C, section 3.
///
/// # Note
/// If a features begins with a number or symbol, the number or symbol will be spelled out.
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Features {
    ThreeSlotEnhancedDataRateAclPackets,
    ThreeSlotEnhancedDataRateEscoPackets,
    ThreeSlotPackets,
    FiveSlotEnhancedDataRateAclPackets,
    FiveSlotPackets,
    ALawLogSynchronousData,
    AfhCapableCentral,
    AfhCapablePeripheral,
    AfhClassificationCentral,
    AfhClassificationPeripheral,
    BrEdrNotSupported,
    BroadcastEncryption,
    ChannelQualityDrivenDataRate,
    ConnectionlessPeripheralBroadcastReceiverOperation,
    ConnectionlessPeripheralBroadcastTransmissionOperation,
    CvsdSynchronousData,
    CoarseClockAdjustment,
    EncapsulatedPdu,
    Encryption,
    EnhancedDataRateAcl2MbsMode,
    EnhancedDataRateAcl3MbsMode,
    EnhancedDataRateEsco2MbsMode,
    EnhancedDataRateEsco3MbsMode,
    EnhancedInquiryScan,
    EnhancedPowerControl,
    ErroneousDataReporting,
    Ev4Packets,
    Ev5Packets,
    ExtendedFeatures,
    ExtendedInquiryResponse,
    ExtendedScoLink,
    FlowControlLag(u8),
    GeneralizedInterlacedScan,
    HoldMode,
    Hv2Packets,
    Hv3Packets,
    InquiryResponseNotificationEvent,
    InterlacedInquiryScan,
    InterlacedPageScan,
    LeSupportedController,
    LeSupportedHost,
    LinkSupervisionTimeoutChangeEvent,
    MuLawLogSynchronousData,
    NonFlushablePacketBoundaryFlag,
    PagingParameterNegotiation,
    PauseEncryption,
    Ping,
    PowerControl,
    PowerControlRequests,
    RoleSwitch,
    RssiWithInquiryResults,
    ScoLink,
    SecureConnectionsControllerSupport,
    SecureConnectionsHostSupport,
    SecureSimplePairingControllerSupport,
    SecureSimplePairingHostSupport,
    SimultaneousLeAndBrEdrToSameDeviceCapable,
    SlotAvailabilityMask,
    SlotOffset,
    SniffMode,
    SniffSubrating,
    SynchronizationScan,
    SynchronizationTrain,
    TimingAccuracy,
    TrainNudging,
    TransparentSynchronousData,
    VariableInquiryTxPowerLevel,
}

macro_rules! is_bit_set {
    ( $bits:ident, ($index:expr,$bit:expr), $enumeration:expr) => {{
        if ($bits[$index] & (1 << $bit)) != 0 {
            Some($enumeration)
        } else {
            None
        }
    }};
}

impl Features {
    /// Check if a feature is enabled
    ///
    /// This is used to check if a feature is enabled within the array `flags`. This takes the
    /// positions `byte` and `bit` to check within `flags`. `byte` is the index of the byte that
    /// contains the flag and `bit` is the mask for the bit within the flag.
    pub fn from_bit(page: usize, byte: usize, bit: u8, flags: &[u8; 8]) -> Option<Self> {
        match (page, byte, bit) {
            (0, 0, 0) => is_bit_set!(flags, (0, 0), Features::ThreeSlotPackets),
            (0, 0, 1) => is_bit_set!(flags, (0, 1), Features::FiveSlotPackets),
            (0, 0, 2) => is_bit_set!(flags, (0, 2), Features::Encryption),
            (0, 0, 3) => is_bit_set!(flags, (0, 3), Features::SlotOffset),
            (0, 0, 4) => is_bit_set!(flags, (0, 4), Features::TimingAccuracy),
            (0, 0, 5) => is_bit_set!(flags, (0, 5), Features::RoleSwitch),
            (0, 0, 6) => is_bit_set!(flags, (0, 6), Features::HoldMode),
            (0, 0, 7) => is_bit_set!(flags, (0, 7), Features::SniffMode),
            (0, 1, 1) => is_bit_set!(flags, (1, 1), Features::PowerControlRequests),
            (0, 1, 2) => is_bit_set!(flags, (1, 2), Features::ChannelQualityDrivenDataRate),
            (0, 1, 3) => is_bit_set!(flags, (1, 3), Features::ScoLink),
            (0, 1, 4) => is_bit_set!(flags, (1, 4), Features::Hv2Packets),
            (0, 1, 5) => is_bit_set!(flags, (1, 5), Features::Hv3Packets),
            (0, 1, 6) => is_bit_set!(flags, (1, 6), Features::MuLawLogSynchronousData),
            (0, 1, 7) => is_bit_set!(flags, (1, 7), Features::ALawLogSynchronousData),
            (0, 2, 0) => is_bit_set!(flags, (2, 0), Features::CvsdSynchronousData),
            (0, 2, 1) => is_bit_set!(flags, (2, 1), Features::PagingParameterNegotiation),
            (0, 2, 2) => is_bit_set!(flags, (2, 2), Features::PowerControl),
            (0, 2, 3) => is_bit_set!(flags, (2, 3), Features::TransparentSynchronousData),
            (0, 2, 4) => {
                let flow_control_lag = flags[2] & (7 << 4);

                if flow_control_lag != 0 {
                    Some(Features::FlowControlLag(flow_control_lag >> 4))
                } else {
                    None
                }
            }
            (0, 2, 7) => is_bit_set!(flags, (2, 7), Features::BroadcastEncryption),
            (0, 3, 1) => is_bit_set!(flags, (3, 1), Features::EnhancedDataRateAcl2MbsMode),
            (0, 3, 2) => is_bit_set!(flags, (3, 2), Features::EnhancedDataRateAcl3MbsMode),
            (0, 3, 3) => is_bit_set!(flags, (3, 3), Features::EnhancedInquiryScan),
            (0, 3, 4) => is_bit_set!(flags, (3, 4), Features::InterlacedInquiryScan),
            (0, 3, 5) => is_bit_set!(flags, (3, 5), Features::InterlacedPageScan),
            (0, 3, 6) => is_bit_set!(flags, (2, 6), Features::RssiWithInquiryResults),
            (0, 3, 7) => is_bit_set!(flags, (3, 7), Features::ExtendedScoLink),
            (0, 4, 0) => is_bit_set!(flags, (4, 0), Features::Ev4Packets),
            (0, 4, 1) => is_bit_set!(flags, (4, 1), Features::Ev5Packets),
            (0, 4, 3) => is_bit_set!(flags, (4, 2), Features::AfhCapablePeripheral),
            (0, 4, 4) => is_bit_set!(flags, (4, 4), Features::AfhClassificationPeripheral),
            (0, 4, 5) => is_bit_set!(flags, (4, 5), Features::BrEdrNotSupported),
            (0, 4, 6) => is_bit_set!(flags, (4, 6), Features::LeSupportedController),
            (0, 4, 7) => is_bit_set!(flags, (4, 7), Features::ThreeSlotEnhancedDataRateAclPackets),
            (0, 5, 0) => is_bit_set!(flags, (5, 0), Features::FiveSlotEnhancedDataRateAclPackets),
            (0, 5, 1) => is_bit_set!(flags, (5, 1), Features::SniffSubrating),
            (0, 5, 2) => is_bit_set!(flags, (5, 2), Features::PauseEncryption),
            (0, 5, 3) => is_bit_set!(flags, (5, 3), Features::AfhCapableCentral),
            (0, 5, 4) => is_bit_set!(flags, (5, 4), Features::AfhClassificationCentral),
            (0, 5, 5) => is_bit_set!(flags, (5, 5), Features::EnhancedDataRateEsco2MbsMode),
            (0, 5, 6) => is_bit_set!(flags, (5, 6), Features::EnhancedDataRateEsco3MbsMode),
            (0, 5, 7) => is_bit_set!(flags, (5, 7), Features::ThreeSlotEnhancedDataRateEscoPackets),
            (0, 6, 0) => is_bit_set!(flags, (6, 0), Features::ExtendedInquiryResponse),
            (0, 6, 7) => is_bit_set!(flags, (6, 7), Features::SimultaneousLeAndBrEdrToSameDeviceCapable),
            (0, 6, 3) => is_bit_set!(flags, (6, 3), Features::SecureSimplePairingControllerSupport),
            (0, 6, 4) => is_bit_set!(flags, (6, 4), Features::EncapsulatedPdu),
            (0, 6, 5) => is_bit_set!(flags, (6, 5), Features::ErroneousDataReporting),
            (0, 6, 6) => is_bit_set!(flags, (6, 6), Features::NonFlushablePacketBoundaryFlag),
            (0, 7, 0) => is_bit_set!(flags, (7, 0), Features::LinkSupervisionTimeoutChangeEvent),
            (0, 7, 1) => is_bit_set!(flags, (7, 1), Features::VariableInquiryTxPowerLevel),
            (0, 7, 2) => is_bit_set!(flags, (7, 2), Features::EnhancedPowerControl),
            (0, 7, 7) => is_bit_set!(flags, (7, 7), Features::ExtendedFeatures),
            (1, 0, 0) => is_bit_set!(flags, (0, 0), Features::SecureSimplePairingHostSupport),
            (1, 0, 1) => is_bit_set!(flags, (0, 1), Features::LeSupportedHost),
            (1, 0, 3) => is_bit_set!(flags, (0, 3), Features::SecureConnectionsHostSupport),
            (2, 0, 0) => is_bit_set!(
                flags,
                (0, 0),
                Features::ConnectionlessPeripheralBroadcastReceiverOperation
            ),
            (2, 0, 1) => is_bit_set!(
                flags,
                (0, 1),
                Features::ConnectionlessPeripheralBroadcastTransmissionOperation
            ),
            (2, 0, 2) => is_bit_set!(flags, (0, 2), Features::SynchronizationTrain),
            (2, 0, 3) => is_bit_set!(flags, (0, 3), Features::SynchronizationScan),
            (2, 0, 4) => is_bit_set!(flags, (0, 4), Features::InquiryResponseNotificationEvent),
            (2, 0, 5) => is_bit_set!(flags, (0, 5), Features::GeneralizedInterlacedScan),
            (2, 0, 6) => is_bit_set!(flags, (0, 6), Features::CoarseClockAdjustment),
            (2, 1, 0) => is_bit_set!(flags, (1, 0), Features::SecureConnectionsControllerSupport),
            (2, 1, 1) => is_bit_set!(flags, (1, 1), Features::Ping),
            (2, 1, 2) => is_bit_set!(flags, (1, 2), Features::SlotAvailabilityMask),
            (2, 1, 3) => is_bit_set!(flags, (1, 3), Features::TrainNudging),
            _ => None,
        }
    }

    /// Get the page
    ///
    /// Features are grouped into pages. Most of the features are on page zero, but some of the
    /// other features are on the other pages. Features on page zero can be discovered
    pub fn page(&self) -> usize {
        match self {
            Features::ThreeSlotEnhancedDataRateAclPackets => 0,
            Features::ThreeSlotEnhancedDataRateEscoPackets => 0,
            Features::ThreeSlotPackets => 0,
            Features::FiveSlotEnhancedDataRateAclPackets => 0,
            Features::FiveSlotPackets => 0,
            Features::ALawLogSynchronousData => 0,
            Features::AfhCapableCentral => 0,
            Features::AfhCapablePeripheral => 0,
            Features::AfhClassificationCentral => 0,
            Features::AfhClassificationPeripheral => 0,
            Features::BrEdrNotSupported => 0,
            Features::BroadcastEncryption => 0,
            Features::ChannelQualityDrivenDataRate => 0,
            Features::ConnectionlessPeripheralBroadcastReceiverOperation => 2,
            Features::ConnectionlessPeripheralBroadcastTransmissionOperation => 2,
            Features::CvsdSynchronousData => 0,
            Features::CoarseClockAdjustment => 2,
            Features::EncapsulatedPdu => 0,
            Features::Encryption => 0,
            Features::EnhancedDataRateAcl2MbsMode => 0,
            Features::EnhancedDataRateAcl3MbsMode => 0,
            Features::EnhancedDataRateEsco2MbsMode => 0,
            Features::EnhancedDataRateEsco3MbsMode => 0,
            Features::EnhancedInquiryScan => 0,
            Features::EnhancedPowerControl => 0,
            Features::ErroneousDataReporting => 0,
            Features::Ev4Packets => 0,
            Features::Ev5Packets => 0,
            Features::ExtendedFeatures => 0,
            Features::ExtendedInquiryResponse => 0,
            Features::ExtendedScoLink => 0,
            Features::FlowControlLag(_) => 0,
            Features::GeneralizedInterlacedScan => 2,
            Features::HoldMode => 0,
            Features::Hv2Packets => 0,
            Features::Hv3Packets => 0,
            Features::InquiryResponseNotificationEvent => 2,
            Features::InterlacedInquiryScan => 0,
            Features::InterlacedPageScan => 0,
            Features::LeSupportedController => 0,
            Features::LeSupportedHost => 1,
            Features::LinkSupervisionTimeoutChangeEvent => 0,
            Features::MuLawLogSynchronousData => 0,
            Features::NonFlushablePacketBoundaryFlag => 0,
            Features::PagingParameterNegotiation => 0,
            Features::PauseEncryption => 0,
            Features::Ping => 2,
            Features::PowerControl => 0,
            Features::PowerControlRequests => 0,
            Features::RoleSwitch => 0,
            Features::RssiWithInquiryResults => 0,
            Features::ScoLink => 0,
            Features::SecureConnectionsControllerSupport => 2,
            Features::SecureConnectionsHostSupport => 1,
            Features::SecureSimplePairingControllerSupport => 0,
            Features::SecureSimplePairingHostSupport => 1,
            Features::SimultaneousLeAndBrEdrToSameDeviceCapable => 0,
            Features::SlotAvailabilityMask => 2,
            Features::SlotOffset => 0,
            Features::SniffMode => 0,
            Features::SniffSubrating => 0,
            Features::SynchronizationScan => 2,
            Features::SynchronizationTrain => 2,
            Features::TimingAccuracy => 0,
            Features::TrainNudging => 2,
            Features::TransparentSynchronousData => 0,
            Features::VariableInquiryTxPowerLevel => 0,
        }
    }
}

/// Features iterator
#[derive(Debug, Clone, Copy)]
pub struct EnabledFeaturesIter {
    page: usize,
    byte: usize,
    bit: u8,
    flags: [u8; 8],
}

impl EnabledFeaturesIter {
    pub fn new(page: usize, flags: [u8; 8]) -> Self {
        EnabledFeaturesIter {
            page,
            byte: 0,
            bit: 0,
            flags,
        }
    }

    /// Resets the iterator back to the beginning of the feature list
    pub fn reset(&mut self) {
        self.byte = 0;
        self.bit = 0;
    }

    /// Get the page of the features
    pub fn page(&self) -> usize {
        self.page
    }
}

impl Iterator for EnabledFeaturesIter {
    type Item = Features;

    fn next(&mut self) -> Option<Self::Item> {
        use core::iter::successors;

        let max_byte = match self.page {
            0 => 7,
            1 => 0,
            2 => 2,
            _ => unreachable!(),
        };

        for byte in successors(Some(self.byte), |byte| (*byte != max_byte).then_some(byte + 1)) {
            for bit in successors(Some(self.bit), |bit| (*bit != 8).then_some(bit + 1)) {
                match Features::from_bit(self.page, byte, bit, &self.flags) {
                    Some(feature) => {
                        self.bit = (bit + 1) % 8;
                        self.byte = if bit + 1 == 8 { byte + 1 } else { byte };

                        return Some(feature);
                    }
                    None => {}
                }
            }
        }

        None
    }
}

impl Display for EnabledFeaturesIter {
    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
        write!(f, "page: {},", self.page)?;
        write!(f, "Enabled features: [")?;

        let mut features = self.clone();

        features.reset();

        for ref feature in features {
            write!(f, "{:?}", feature)?;
        }

        write!(f, "]")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn invalid_static_device_address() {
        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsZero),
            BluetoothDeviceAddress::try_from_static([0; 6])
        );

        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_static([0xFF; 6])
        );

        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_static([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F])
        )
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn invalid_non_resolvable_private_address() {
        assert_eq!(
            Err(errors::NonResolvableError::AddressIsZero),
            BluetoothDeviceAddress::try_from_non_resolvable([0; 6])
        );

        assert_eq!(
            Err(errors::NonResolvableError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_non_resolvable([0xFF; 6])
        );

        assert_eq!(
            Err(errors::NonResolvableError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_non_resolvable([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F])
        );
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn invalid_resolvable_private_address() {
        let irk = 1234u128;

        assert_eq!(
            Err(errors::ResolvableError::PRandIsZero),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0; 3])
        );

        assert_eq!(
            Err(errors::ResolvableError::PRandIsAllOnes),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0xFF; 3])
        );

        assert_eq!(
            Err(errors::ResolvableError::PRandIsAllOnes),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0xFF, 0xFF, 0x3F])
        );
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn resolve_resolvable_private_address() {
        let irk = 123456u128;

        let p_rand = [0x12, 0x23, 0x34];

        let rpa = BluetoothDeviceAddress::try_from_resolvable(irk, p_rand).unwrap();

        assert!(rpa.resolve(irk));
    }

    #[test]
    fn bluetooth_addr_ui_representation() {
        assert_eq!(
            Ok(BluetoothDeviceAddress([0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12])),
            BluetoothDeviceAddress::try_from("123456789abc")
        );

        assert_eq!(
            Ok(BluetoothDeviceAddress([0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12])),
            BluetoothDeviceAddress::try_from("12:34:56:78:9a:bc")
        );

        // The Bluetooth Specification does not have a common format
        // when using colons to split an address into sub-slices. This
        // might be shown in a UI where the address is split into the
        // LAP, UAP, and NAP parts.
        assert_eq!(
            Ok(BluetoothDeviceAddress([0x56, 0x34, 0x12, 0xef, 0xcd, 0xab])),
            BluetoothDeviceAddress::try_from("abcdef:12:3456")
        );

        // Repetitions of colons are not allowed.
        assert_eq!(
            Err(BluetoothDeviceAddress::REPEATED_COLONS),
            BluetoothDeviceAddress::try_from("ab::cd::ef::12::34::56")
        );

        // Colon(s) at the front are not allowed
        assert_eq!(
            Err(BluetoothDeviceAddress::COLON_AT_FRONT),
            BluetoothDeviceAddress::try_from(":abcdef123456")
        );

        // Colon(s) at the back are not allowed
        assert_eq!(
            Err(BluetoothDeviceAddress::COLON_AT_BACK),
            BluetoothDeviceAddress::try_from("abcdef123456:")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::INVALID_CHARS),
            BluetoothDeviceAddress::try_from("hello_worlds")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_MANY_CHARS),
            BluetoothDeviceAddress::try_from("123456789abcd")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_FEW_CHARS),
            BluetoothDeviceAddress::try_from("123456789ab")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_FEW_CHARS),
            BluetoothDeviceAddress::try_from("123456789a")
        );
    }

    #[test]
    fn enabled_features_iter_test() {
        use self::Features::*;

        let features = [
            ThreeSlotPackets,
            FiveSlotPackets,
            Encryption,
            SlotOffset,
            TimingAccuracy,
            RoleSwitch,
            HoldMode,
            SniffMode,
            PowerControlRequests,
            Hv2Packets,
            Hv3Packets,
            PagingParameterNegotiation,
            FlowControlLag(2),
            BroadcastEncryption,
            Ev4Packets,
            AfhCapablePeripheral,
            BrEdrNotSupported,
            LeSupportedController,
            VariableInquiryTxPowerLevel,
        ];

        let raw = [0xFF, 0x32, 0xA2, 0x00, 0x65, 0x00, 0x00, 0x02];

        for feature in EnabledFeaturesIter::new(0, raw) {
            assert!(
                features.iter().find(|&&x| x == feature).is_some(),
                "Didn't find feature {:?} in list",
                feature
            );
        }
    }
}
