//! LE Privacy
//!
//! Privacy is a way for two devices to reconnect and re-encrypt without having to go through
//! pairing. When two devices are in a non-connected state, they will use resolvable private
//! addresses to determine what devices to connect to. A resolvable private address requires an
//! identity resolving key to *resolve*, and in doing so authenticate the identity of a connecting
//! or advertising device.
//!
//! There is two major ways to perform privacy in a peripheral. The most common way is to utilize
//! the resolvable private in the Bluetooth Controller to only generate HCI connection events for
//! private address that are successfully resolved. The other way is to have the host perform
//! resolving on all connections and disconnect those whose addresses are either not a resolvable
//! private address or no stored Identity Resolving Keys can resolve them.

mod controller_privacy;
pub mod host_privacy;

use bo_tie::hci::{Connection, Host, HostChannelEnds};
use bo_tie::host::sm::{IdentityAddress, Keys};
use bo_tie::LeFeatures;

enum PrivacyMode {
    Controller(controller_privacy::Controller),
    Host(host_privacy::HostPrivacy),
}

/// Structure for using Privacy for the selected Controller
///
/// This combines both the Controller Privacy and Host Privacy routines into one type. Controller
/// privacy is always preferred over Host implemented privacy if the Controller supports the feature
/// LE Privacy.
///
/// `Privacy` has two "modes", *controller* and *host*. In *Controller* mode the Bluetooth
/// Controller performs the generation and resolving of resolvable private addresses. In *host* mode
/// this example will do the generation and resolving of resolvable private addresses. The mode is
/// determined by checking if the Bluetooth Controller has the LE feature `LL Privacy`. If it does
/// then *controller* is set as the mode, but if it does not then the mode is *host*.
pub struct Privacy {
    mode: PrivacyMode,
}

impl Privacy {
    /// Create a new `Privacy`
    ///
    /// This first queries the Controller for the LE local features to determine if `LL Privacy` is
    /// available in the controller, then a `Privacy` is created`.
    pub async fn new<H: HostChannelEnds>(host: &mut Host<H>) -> Self {
        use bo_tie::hci::commands::le::read_local_supported_features;

        let features = read_local_supported_features::send(host).await.unwrap();

        let has_privacy_feature = features.iter().any(|feature| feature == LeFeatures::LlPrivacy);

        let mode = if has_privacy_feature {
            PrivacyMode::Controller(controller_privacy::Controller::new())
        } else {
            PrivacyMode::Host(host_privacy::HostPrivacy::new())
        };

        Self { mode }
    }

    /// Add a device to the resolving list
    pub async fn add_device_to_resolving_list<H: HostChannelEnds>(&mut self, host: &mut Host<H>, keys: &Keys) {
        match &mut self.mode {
            PrivacyMode::Controller(c) => c.add_device_resolving_list(host, keys).await,
            PrivacyMode::Host(h) => h.add_to_resolving_list(keys),
        }
    }

    pub async fn remove_device_from_resolving_list<H: HostChannelEnds>(
        &mut self,
        host: &mut Host<H>,
        identity: &IdentityAddress,
        hard_remove: bool,
    ) {
        match &mut self.mode {
            PrivacyMode::Controller(c) => c.remove_device_from_resolving_list(host, identity).await,
            PrivacyMode::Host(h) => h.remove_device_from_resolving_list(identity, hard_remove),
        }
    }

    /// Clear all devices from the resolving list
    pub async fn clear_resolving_list<H: HostChannelEnds>(&mut self, host: &mut Host<H>) {
        match &mut self.mode {
            PrivacyMode::Controller(c) => c.clear_resolving_list(host).await,
            PrivacyMode::Host(h) => h.clear_resolving_list(),
        }
    }

    /// Set the timeout
    ///
    /// This sets the timeout for the resolvable private addresses (RPA) within the advertisement.
    /// When the Controller is used it will create a new resolvable private address after the
    /// timeout is complete. If resolvable private address are generated by the host, then
    /// `set_timeout` will return an [`Interval`]. Everytime `Interval` creates a tick, the method
    /// [`host_regen_addresses`] must be called.
    ///
    /// [`host_regen_address`]: Privacy::host_regen_address
    pub async fn set_timeout<H, T>(&mut self, host: &mut Host<H>, timeout: T) -> TimeoutTick
    where
        H: HostChannelEnds,
        T: Into<Option<std::time::Duration>>,
    {
        let timeout = timeout.into().unwrap_or(std::time::Duration::from_secs(900));

        match &mut self.mode {
            PrivacyMode::Controller(c) => {
                c.set_timeout(host, timeout).await;

                TimeoutTick::default()
            }
            PrivacyMode::Host(h) => {
                let tick = h.set_timeout(timeout).into();

                TimeoutTick { tick }
            }
        }
    }

    /// Setup Advertising with Resolvable Private Addresses
    pub async fn start_private_advertising<H: HostChannelEnds>(&mut self, host: &mut Host<H>) {
        match &mut self.mode {
            PrivacyMode::Controller(c) => c.start_private_advertising(host).await,
            PrivacyMode::Host(h) => h.start_private_advertising(host).await,
        }
    }

    /// Validate a Connection
    ///
    /// In *host* mode this validates the address of the device that initiated the connection is
    /// resolvable. In *controller* mode this is effectively a no-op.
    ///
    /// If the device address cannot be resolved, the connection will be sent the disconnection
    /// command with the error "invalid authorization".
    pub fn validate<C>(&mut self, connection: &Connection<C>) -> Option<IdentityAddress> {
        match &mut self.mode {
            PrivacyMode::Host(h) => h.validate_connection(connection),
            PrivacyMode::Controller(c) => c.get_identified(connection).into(),
        }
    }
}

#[derive(Default)]
pub struct TimeoutTick {
    tick: Option<host_privacy::RpaInterval>,
}

impl TimeoutTick {
    pub async fn tick(&mut self) -> RegenIrk {
        match &mut self.tick {
            Some(timout_tick) => {
                let regen = timout_tick.tick().await;

                RegenIrk { regen }
            }
            None => std::future::pending().await,
        }
    }
}

#[must_use]
pub struct RegenIrk {
    regen: host_privacy::RegenRpa,
}

impl RegenIrk {
    pub async fn regen<H: HostChannelEnds>(self, host: &mut Host<H>) {
        self.regen.regen(host).await
    }
}
