//! Core functionality for `bo-tie`
//!
//! Unlike most `core` libraries of rust, `bo-tie-core` is not intended to be usable on its own. It
//! is purely a supporting library for all other libraries within the `bo-tie` workspace. Types used
//! throughout `bo-tie` are collected here as a common place to put them.

#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]

#[cfg(feature = "alloc")]
extern crate alloc;

pub mod buffer;
#[cfg(feature = "cryptography")]
pub mod cryptography;
pub mod errors;

use core::fmt::{Display, Formatter, LowerHex, UpperHex};
use core::ops::{Deref, DerefMut};

/// A Bluetooth device address
///
/// This is a wrapper around a six byte array. The address shall always be represented in little
/// endian format within a `BluetoothDeviceAddress`.
///
/// # Address Types
/// A Bluetooth device address can either be a public address, a static device address, a
/// resolvable private address, or a non-resolvable private address. Bluetooth BR/EDR operation only
/// uses public addresses, but Bluetooth LE uses all four types of address.
///
/// A public address is the address is hardwired into the device. It must be retrieved from the
/// controller in order to be used by the host protocols. When using the host controller interface
/// implementation it can be acquired from the *Information Parameters* command *Read BR_ADDR*.
///
/// A static device address is generated by the host and set to a *LE* controller. It can be
/// any address so long as the random part (the least significant 46 bits) are not all either zero
/// or one. A static device address can act as an identity address (see the Security Manager
/// Protocol) but it must be saved by the host and resent upon controller reset.
///
/// A resolvable private address is *usually* a controller generated address for use in Bluetooth
/// *LE* privacy. Its main usage is for identifying a device through "resolving" an address using an
/// identity resolving key (resolving is essentially inputting the address and the identity
/// resolving key into a cypher function and seeing if the output is zero). The most common usage
/// of this is to re-establish encryption after reconnecting two LE devices.
///
/// A non-resolvable private address is a host generated address sent to the *LE* controller.
/// A non-resolvable private address is used where it is desired for the public or static device
/// address to not be known for privacy reasons, but a resolvable private address is not needed or
/// used.
///
/// # UI Representation
/// A `BluetoothDeviceAddress` can be created from the UI Representation form. This is a string
/// formatted as either twelve consecutive hexadecimals (`"XXXXXXXXXXXX"`) or separated using
/// a colon (e.g. `"XX:XX:XX:XX:XX:XX"`).
///
/// A `BluetoothDeviceAddress` can be converted into the UI representation with colons through its
/// implementation of [`Display`](core::fmt::Display). If the format with just twelve hexidecimal
/// digits is desired, it can be done using either the implementation for
/// [`LowerHex`](core::fmt::LowerHex) or [`UpperHex`](core::fmt::UpperHex).
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BluetoothDeviceAddress(pub [u8; 6]);

impl BluetoothDeviceAddress {
    /// Create a public address
    ///
    /// This creates a public address from its MAC components.
    pub fn new_public(lap: [u8; 3], uap: u8, nap: [u8; 2]) -> Self {
        BluetoothDeviceAddress([nap[0], nap[1], uap, lap[0], lap[1], lap[2]])
    }

    /// Create a `BluetoothDeviceAddress` containing a randomly generated static device address
    #[cfg(feature = "sys-rand")]
    pub fn new_static_random() -> Self {
        use rand_core::RngCore;

        let mut a = [0u8; 6];

        loop {
            rand_core::OsRng.fill_bytes(&mut a);

            if let Ok(this) = Self::try_from_static_random(a) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a random static device address
    ///
    /// The returned `BluetoothDeviceAddress` will contain `addr` with the marker bits for a random static
    /// device address. The only way this will fail in creating a `BluetoothDeviceAddress` is if
    /// input `addr` is equal to zero or all bits from zero through forty-five are one.
    ///
    /// # Note
    /// The marker bits for a static device address do not need to be in `addr`. This method will
    /// set the bits within the address before returning a `BluetoothDeviceAddress`.
    pub fn try_from_static_random(mut addr: [u8; 6]) -> Result<Self, errors::StaticDeviceError> {
        // The tag for static device address is 0b11 in the
        // two most significant bits.
        addr[5] |= 0b1100_0000;

        if addr == [0xFF; 6] {
            Err(errors::StaticDeviceError::AddressIsAllOnes)
        } else if addr == [0, 0, 0, 0, 0, 0xC0] {
            Err(errors::StaticDeviceError::AddressIsZero)
        } else {
            Ok(Self(addr))
        }
    }

    /// Create a `BluetoothDeviceAddress` containing a non-resolvable random private address
    #[cfg(feature = "sys-rand")]
    pub fn new_non_resolvable() -> Self {
        use rand_core::RngCore;

        let mut a = [0u8; 6];

        loop {
            rand_core::OsRng.fill_bytes(&mut a);

            if let Ok(this) = Self::try_from_non_resolvable(a) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a non-resolvable random private address
    ///
    /// The returned `BluetoothDeviceAddress` will contain `addr` with the marker bits for a
    /// non-resolvable random private address. The only way this will fail in creating a
    /// `BluetoothDeviceAddress` is if input `addr` is equal to zero or all bits from
    /// zero through forty-five are one.
    ///
    /// # Note
    /// The marker bits for a non-resolvable private address do not need to be in `addr`. This
    /// method will set the bits within the address before returning a `BluetoothDeviceAddress`.
    pub fn try_from_non_resolvable(mut addr: [u8; 6]) -> Result<Self, errors::NonResolvableError> {
        // The tag for a non resolvable private address is
        // 0b00 in the two most significant bits
        addr[5] &= 0b0011_1111;

        if [0u8; 6] == addr {
            Err(errors::NonResolvableError::AddressIsZero)
        } else if [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F] == addr {
            Err(errors::NonResolvableError::AddressIsAllOnes)
        } else {
            return Ok(Self(addr));
        }
    }

    /// Create a `BluetoothDeviceAddress` containing a resolvable random private address
    ///
    /// The input is an identity resolving key (`irk`) that is used to generate the resolvable random
    /// private address.
    ///
    /// # Note
    /// This method is only needed if the application is using *host based* privacy. See the Bluetooth Specification
    /// about the resolving list for Controller based privacy.
    #[cfg(all(feature = "sys-rand", feature = "cryptography"))]
    pub fn new_resolvable(irk: u128) -> Self {
        use rand_core::RngCore;

        let mut p_rand = [0u8; 3];

        loop {
            rand_core::OsRng.fill_bytes(&mut p_rand);

            if let Ok(this) = Self::try_from_resolvable(irk, p_rand) {
                return this;
            }
        }
    }

    /// Try to create a `BluetoothDeviceAddress` containing a resolvable random private address
    ///
    /// This takes an identity resolving key (`irk`) and a randomly generated three byte number
    /// (`p_rand`). An identity resolving key is a cryptographic symmetric key only shared with
    /// other devices that are bonded with this device. The returned address can only be *easily*
    /// resolved by devices that also have the `irk` used to generate it.
    ///
    /// A resolvable random private address consists of a hast and a random part. The first three
    /// bytes of a resolvable address is the hash value, and it is generated using inputs `irk`
    /// and `p_rand`. The last three bytes of the address are the random part and they are set
    /// to input `p_rand`.
    ///
    /// # Error
    /// Input `p_rand` cannot be zero or all ones within bits zero to twenty-two. The last two most
    /// significant bits are used to mark the address as a resolvable private address. This method
    /// will set those bits to `0b01` before generating the hash part of the resolvable address.
    #[cfg(feature = "cryptography")]
    pub fn try_from_resolvable(irk: u128, mut p_rand: [u8; 3]) -> Result<Self, errors::ResolvableError> {
        // The tag for a resolvable private address is 0b01
        // in the two most significant bits.
        //
        // `p_rand[2]` will become the most significant
        // byte of the resolvable private address.
        p_rand[2] = p_rand[2] & 0b0011_1111 | 0b0100_0000;

        if [0, 0, 0x40] == p_rand {
            Err(errors::ResolvableError::PRandIsZero)
        } else if [0xFF, 0xFF, 0x7F] == p_rand {
            Err(errors::ResolvableError::PRandIsAllOnes)
        } else {
            let mut address = [0, 0, 0, p_rand[0], p_rand[1], p_rand[2]];

            address[..3].copy_from_slice(&cryptography::ah(irk, p_rand));

            Ok(Self(address))
        }
    }

    /// Try to resolve this address
    ///
    /// This method should only be called if this address is a resolvable private address.
    ///
    /// `true` is returned if `irk` was the identity resolving key used to generate this Bluetooth
    /// address. `false` is returned  if `irk` was not the correct key or this address is not a
    /// resolvable private address.
    #[cfg(feature = "cryptography")]
    pub fn resolve(&self, irk: u128) -> bool {
        let (peer_hash, p_rand) = self.0.split_at(3);

        let hash = cryptography::ah(irk, [p_rand[0], p_rand[1], p_rand[2]]);

        // Check if p_rand has the correct signature for a resolvable private address
        // (the most significant two bits must be 0b01) and the hashes match.
        (p_rand[2] & 0b1100_0000 == 0b0100_0000) && (peer_hash == hash)
    }

    /// Create a `BluetoothDeviceAddress` containing all zeros
    ///
    /// An address with all zeros is an invalid address an cannot be used for Bluetooth operations.
    /// The bytes of the returned address should be modified after it is created.
    pub fn zeroed() -> Self {
        Self([0; 6])
    }

    //=============================================
    // Error returns for implementation of TryFrom
    //=============================================
    const TOO_FEW_CHARS: &'static str = "address contains too few digits";
    const TOO_MANY_CHARS: &'static str = "address contains too many digits";
    const INVALID_CHARS: &'static str = "address contains invalid characters";
    const REPEATED_COLONS: &'static str = "multiple consecutive colons separating characters";
    const COLON_AT_FRONT: &'static str = "colon in front of the address";
    const COLON_AT_BACK: &'static str = "colon at the end of the address";
}

impl Deref for BluetoothDeviceAddress {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for BluetoothDeviceAddress {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl TryFrom<&str> for BluetoothDeviceAddress {
    type Error = &'static str;

    fn try_from(source: &str) -> Result<Self, Self::Error> {
        macro_rules! next_char {
            ($iter:expr) => {
                match $iter.next().ok_or(Self::TOO_FEW_CHARS)? {
                    ':' => match $iter.next().ok_or(Self::TOO_FEW_CHARS)? {
                        ':' => return Err(Self::REPEATED_COLONS)?,
                        c => c,
                    },
                    c => c,
                }
            };
        }

        if let ':' = source.chars().next().ok_or(Self::TOO_FEW_CHARS)? {
            return Err(Self::COLON_AT_FRONT);
        }

        if let Some(':') = source.chars().next_back() {
            return Err(Self::COLON_AT_BACK);
        }

        let mut address = [0u8; 6];

        let mut addr_chars_iter = source.chars().rev().fuse();

        for byte in address.iter_mut() {
            let mut src_buffer = [0u8; core::mem::size_of::<char>() * 2];

            let char_ms = next_char!(addr_chars_iter);

            let char_ls = next_char!(addr_chars_iter);

            let char_ms_len = char_ms.len_utf8();

            let char_ls_len = char_ls.len_utf8();

            let src_len = char_ms_len + char_ls_len;

            char_ls.encode_utf8(&mut src_buffer);

            char_ms.encode_utf8(&mut src_buffer[char_ls_len..]);

            let src = unsafe { core::str::from_utf8_unchecked(&src_buffer[..src_len]) };

            *byte = u8::from_str_radix(&src, 16).or(Err(Self::INVALID_CHARS))?;
        }

        match addr_chars_iter.next() {
            Some(_) => Err(Self::TOO_MANY_CHARS),
            None => Ok(Self(address)),
        }
    }
}

impl TryFrom<&[u8]> for BluetoothDeviceAddress {
    type Error = core::array::TryFromSliceError;

    fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
        let inner = <[u8; 6]>::try_from(slice)?;

        Ok(BluetoothDeviceAddress(inner))
    }
}

impl core::str::FromStr for BluetoothDeviceAddress {
    type Err = &'static str;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        TryFrom::try_from(s)
    }
}

impl Display for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

impl LowerHex for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

impl UpperHex for BluetoothDeviceAddress {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(
            f,
            "{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}",
            self.0[5], self.0[4], self.0[3], self.0[2], self.0[1], self.0[0]
        )
    }
}

/// List of Device Features
///
/// This is the list of the general supported device features of the BR/EDR Controller, but they are
/// also used by a LE (only) Controller. This does not include the LE supported features (which can
/// be found within [`LeDeviceFeatures`]. This list can be found within the Bluetooth Specification
/// in volume 2, part C, section 3.
///
/// # Note
/// If a features begins with a number or symbol, the number or symbol will be spelled out.
#[derive(Clone, Copy, Eq, PartialEq, Debug, Ord, PartialOrd, Hash)]
pub enum Features {
    ThreeSlotEnhancedDataRateAclPackets,
    ThreeSlotEnhancedDataRateEscoPackets,
    ThreeSlotPackets,
    FiveSlotEnhancedDataRateAclPackets,
    FiveSlotPackets,
    ALawLogSynchronousData,
    AfhCapableCentral,
    AfhCapablePeripheral,
    AfhClassificationCentral,
    AfhClassificationPeripheral,
    BrEdrNotSupported,
    BroadcastEncryption,
    ChannelQualityDrivenDataRate,
    ConnectionlessPeripheralBroadcastReceiverOperation,
    ConnectionlessPeripheralBroadcastTransmissionOperation,
    CvsdSynchronousData,
    CoarseClockAdjustment,
    EncapsulatedPdu,
    Encryption,
    EnhancedDataRateAcl2MbsMode,
    EnhancedDataRateAcl3MbsMode,
    EnhancedDataRateEsco2MbsMode,
    EnhancedDataRateEsco3MbsMode,
    EnhancedInquiryScan,
    EnhancedPowerControl,
    ErroneousDataReporting,
    Ev4Packets,
    Ev5Packets,
    ExtendedFeatures,
    ExtendedInquiryResponse,
    ExtendedScoLink,
    FlowControlLag(u8),
    GeneralizedInterlacedScan,
    HoldMode,
    Hv2Packets,
    Hv3Packets,
    InquiryResponseNotificationEvent,
    InterlacedInquiryScan,
    InterlacedPageScan,
    LeSupportedController,
    LeSupportedHost,
    LinkSupervisionTimeoutChangeEvent,
    MuLawLogSynchronousData,
    NonFlushablePacketBoundaryFlag,
    PagingParameterNegotiation,
    PauseEncryption,
    Ping,
    PowerControl,
    PowerControlRequests,
    RoleSwitch,
    RssiWithInquiryResults,
    ScoLink,
    SecureConnectionsControllerSupport,
    SecureConnectionsHostSupport,
    SecureSimplePairingControllerSupport,
    SecureSimplePairingHostSupport,
    SimultaneousLeAndBrEdrToSameDeviceCapable,
    SlotAvailabilityMask,
    SlotOffset,
    SniffMode,
    SniffSubrating,
    SynchronizationScan,
    SynchronizationTrain,
    TimingAccuracy,
    TrainNudging,
    TransparentSynchronousData,
    VariableInquiryTxPowerLevel,
}

macro_rules! is_bit_set {
    ( $bits:ident, ($index:expr,$bit:expr), $enumeration:expr) => {{
        $bits
            .get($index)
            .and_then(|byte| byte.checked_shl($bit).map(|mask| byte & mask))
            .and_then(|masked| (masked != 0).then_some($enumeration))
    }};
}

impl Features {
    /// The size of features page 0 in bytes
    pub const PAGE_0_SIZE: usize = 8;

    /// The size of features page 1 in bytes
    pub const PAGE_1_SIZE: usize = 1;

    /// The size of features page 2 in bytes
    pub const PAGE_2_SIZE: usize = 2;

    /// The size of the normal LMP features
    pub const NORMAL_LMP_FEATURES_SIZE: usize = Self::PAGE_0_SIZE;

    /// Check if this `Feature` is enabled within a bit map of features.
    ///
    /// Input `features` is a bit field for enabled LMP features and `page` is the number for the
    /// features page. This checks if this feature is enabled within `features`.
    pub fn check_within(self, page: usize, features: &[u8]) -> bool {
        let (this_page, index, bit) = self.position();

        (page == this_page)
            .then(|| Self::check_by_pos(page, index, bit, features))
            .is_some()
    }

    /// Check by position for a feature within a bit map of features.
    ///
    /// This is used to check if a feature is enabled within the bit map `features`. Features are
    /// group by their `page`. The normal LMP features are on page zero and the extended LMP
    /// features are on page one or two. Different pages have different features and so the bit
    /// within `features` are interpreted differently depending on the value of `page`. Input `byte`
    /// is used as the indexer to get the byte within `features`. Input `bit` is the bit position
    /// of the feature within the byte indexed by `byte`. If this bit is one then the corresponding
    /// `Feature` is returned, but if the bit is zero then `None` is returned. `None` is also
    /// returned if any of the inputs are invalid.
    ///
    /// Method [`check_within`] is much easier to use and should be used over `check_by_pos`.
    ///
    /// # Input Validation
    /// * `page` can be 0, 1, or 2.
    /// * `byte` must be less than the size of the features page.
    ///   - If `page` is 0 then `byte` must be less than 8.
    ///   - If `page` is 1 then `byte` must be equal to 0.
    ///   - If `page` is 2 then `byte` must be less than 3.
    /// * `bit` mut be less than 8.
    /// * `features` *should* match the size of the page. If it is less than the expected size any
    ///   feature flags that map beyond the bounds of `features` are assumed to be disabled.
    ///   - `features` should be 8 bytes long if `page` is 0.
    ///   - `features` should be 1 byte long if `page` is 1.
    ///   - `features` should be 3 bytes long if `page` is 2.
    ///
    /// [`check_within`]: Features::check_within
    pub fn check_by_pos(page: usize, byte: usize, bit: usize, features: &[u8]) -> Option<Self> {
        match (page, byte, bit) {
            (0, 0, 0) => is_bit_set!(features, (0, 0), Features::ThreeSlotPackets),
            (0, 0, 1) => is_bit_set!(features, (0, 1), Features::FiveSlotPackets),
            (0, 0, 2) => is_bit_set!(features, (0, 2), Features::Encryption),
            (0, 0, 3) => is_bit_set!(features, (0, 3), Features::SlotOffset),
            (0, 0, 4) => is_bit_set!(features, (0, 4), Features::TimingAccuracy),
            (0, 0, 5) => is_bit_set!(features, (0, 5), Features::RoleSwitch),
            (0, 0, 6) => is_bit_set!(features, (0, 6), Features::HoldMode),
            (0, 0, 7) => is_bit_set!(features, (0, 7), Features::SniffMode),
            (0, 1, 1) => is_bit_set!(features, (1, 1), Features::PowerControlRequests),
            (0, 1, 2) => is_bit_set!(features, (1, 2), Features::ChannelQualityDrivenDataRate),
            (0, 1, 3) => is_bit_set!(features, (1, 3), Features::ScoLink),
            (0, 1, 4) => is_bit_set!(features, (1, 4), Features::Hv2Packets),
            (0, 1, 5) => is_bit_set!(features, (1, 5), Features::Hv3Packets),
            (0, 1, 6) => is_bit_set!(features, (1, 6), Features::MuLawLogSynchronousData),
            (0, 1, 7) => is_bit_set!(features, (1, 7), Features::ALawLogSynchronousData),
            (0, 2, 0) => is_bit_set!(features, (2, 0), Features::CvsdSynchronousData),
            (0, 2, 1) => is_bit_set!(features, (2, 1), Features::PagingParameterNegotiation),
            (0, 2, 2) => is_bit_set!(features, (2, 2), Features::PowerControl),
            (0, 2, 3) => is_bit_set!(features, (2, 3), Features::TransparentSynchronousData),
            (0, 2, 4) | (0, 2, 5) | (0, 2, 6) => {
                let flow_control_lag = features[2] & (7 << 4);

                if flow_control_lag != 0 {
                    Some(Features::FlowControlLag(flow_control_lag >> 4))
                } else {
                    None
                }
            }
            (0, 2, 7) => is_bit_set!(features, (2, 7), Features::BroadcastEncryption),
            (0, 3, 1) => is_bit_set!(features, (3, 1), Features::EnhancedDataRateAcl2MbsMode),
            (0, 3, 2) => is_bit_set!(features, (3, 2), Features::EnhancedDataRateAcl3MbsMode),
            (0, 3, 3) => is_bit_set!(features, (3, 3), Features::EnhancedInquiryScan),
            (0, 3, 4) => is_bit_set!(features, (3, 4), Features::InterlacedInquiryScan),
            (0, 3, 5) => is_bit_set!(features, (3, 5), Features::InterlacedPageScan),
            (0, 3, 6) => is_bit_set!(features, (2, 6), Features::RssiWithInquiryResults),
            (0, 3, 7) => is_bit_set!(features, (3, 7), Features::ExtendedScoLink),
            (0, 4, 0) => is_bit_set!(features, (4, 0), Features::Ev4Packets),
            (0, 4, 1) => is_bit_set!(features, (4, 1), Features::Ev5Packets),
            (0, 4, 3) => is_bit_set!(features, (4, 2), Features::AfhCapablePeripheral),
            (0, 4, 4) => is_bit_set!(features, (4, 4), Features::AfhClassificationPeripheral),
            (0, 4, 5) => is_bit_set!(features, (4, 5), Features::BrEdrNotSupported),
            (0, 4, 6) => is_bit_set!(features, (4, 6), Features::LeSupportedController),
            (0, 4, 7) => is_bit_set!(features, (4, 7), Features::ThreeSlotEnhancedDataRateAclPackets),
            (0, 5, 0) => is_bit_set!(features, (5, 0), Features::FiveSlotEnhancedDataRateAclPackets),
            (0, 5, 1) => is_bit_set!(features, (5, 1), Features::SniffSubrating),
            (0, 5, 2) => is_bit_set!(features, (5, 2), Features::PauseEncryption),
            (0, 5, 3) => is_bit_set!(features, (5, 3), Features::AfhCapableCentral),
            (0, 5, 4) => is_bit_set!(features, (5, 4), Features::AfhClassificationCentral),
            (0, 5, 5) => is_bit_set!(features, (5, 5), Features::EnhancedDataRateEsco2MbsMode),
            (0, 5, 6) => is_bit_set!(features, (5, 6), Features::EnhancedDataRateEsco3MbsMode),
            (0, 5, 7) => is_bit_set!(features, (5, 7), Features::ThreeSlotEnhancedDataRateEscoPackets),
            (0, 6, 0) => is_bit_set!(features, (6, 0), Features::ExtendedInquiryResponse),
            (0, 6, 7) => is_bit_set!(features, (6, 7), Features::SimultaneousLeAndBrEdrToSameDeviceCapable),
            (0, 6, 3) => is_bit_set!(features, (6, 3), Features::SecureSimplePairingControllerSupport),
            (0, 6, 4) => is_bit_set!(features, (6, 4), Features::EncapsulatedPdu),
            (0, 6, 5) => is_bit_set!(features, (6, 5), Features::ErroneousDataReporting),
            (0, 6, 6) => is_bit_set!(features, (6, 6), Features::NonFlushablePacketBoundaryFlag),
            (0, 7, 0) => is_bit_set!(features, (7, 0), Features::LinkSupervisionTimeoutChangeEvent),
            (0, 7, 1) => is_bit_set!(features, (7, 1), Features::VariableInquiryTxPowerLevel),
            (0, 7, 2) => is_bit_set!(features, (7, 2), Features::EnhancedPowerControl),
            (0, 7, 7) => is_bit_set!(features, (7, 7), Features::ExtendedFeatures),
            (1, 0, 0) => is_bit_set!(features, (0, 0), Features::SecureSimplePairingHostSupport),
            (1, 0, 1) => is_bit_set!(features, (0, 1), Features::LeSupportedHost),
            (1, 0, 3) => is_bit_set!(features, (0, 3), Features::SecureConnectionsHostSupport),
            (2, 0, 0) => is_bit_set!(
                features,
                (0, 0),
                Features::ConnectionlessPeripheralBroadcastReceiverOperation
            ),
            (2, 0, 1) => is_bit_set!(
                features,
                (0, 1),
                Features::ConnectionlessPeripheralBroadcastTransmissionOperation
            ),
            (2, 0, 2) => is_bit_set!(features, (0, 2), Features::SynchronizationTrain),
            (2, 0, 3) => is_bit_set!(features, (0, 3), Features::SynchronizationScan),
            (2, 0, 4) => is_bit_set!(features, (0, 4), Features::InquiryResponseNotificationEvent),
            (2, 0, 5) => is_bit_set!(features, (0, 5), Features::GeneralizedInterlacedScan),
            (2, 0, 6) => is_bit_set!(features, (0, 6), Features::CoarseClockAdjustment),
            (2, 1, 0) => is_bit_set!(features, (1, 0), Features::SecureConnectionsControllerSupport),
            (2, 1, 1) => is_bit_set!(features, (1, 1), Features::Ping),
            (2, 1, 2) => is_bit_set!(features, (1, 2), Features::SlotAvailabilityMask),
            (2, 1, 3) => is_bit_set!(features, (1, 3), Features::TrainNudging),
            _ => None,
        }
    }

    /// Get the position of the feature
    ///
    /// This returns the page, byte, and bit (in that order) of the feature.
    ///
    /// # Note
    /// The feature [`FlowControlLag`] uses 3 bits within the features array. The returned bit is
    /// the least significant bit of the feature, so the two subsequent bits are also part of
    /// `FlowControlLag`. The value within `FlowControlLag` has no effect on method `page`.
    ///
    /// [`FlowControlLag`]: Features::FlowControlLag
    pub fn position(self) -> (usize, usize, usize) {
        match self {
            Features::ThreeSlotPackets => (0, 0, 0),
            Features::FiveSlotPackets => (0, 0, 1),
            Features::Encryption => (0, 0, 2),
            Features::SlotOffset => (0, 0, 3),
            Features::TimingAccuracy => (0, 0, 4),
            Features::RoleSwitch => (0, 0, 5),
            Features::HoldMode => (0, 0, 6),
            Features::SniffMode => (0, 0, 7),
            Features::PowerControlRequests => (0, 1, 1),
            Features::ChannelQualityDrivenDataRate => (0, 1, 2),
            Features::ScoLink => (0, 1, 3),
            Features::Hv2Packets => (0, 1, 4),
            Features::Hv3Packets => (0, 1, 5),
            Features::MuLawLogSynchronousData => (0, 1, 6),
            Features::ALawLogSynchronousData => (0, 1, 7),
            Features::CvsdSynchronousData => (0, 2, 0),
            Features::PagingParameterNegotiation => (0, 2, 1),
            Features::PowerControl => (0, 2, 2),
            Features::TransparentSynchronousData => (0, 2, 3),
            Features::FlowControlLag(_) => (0, 2, 4),
            Features::BroadcastEncryption => (0, 2, 7),
            Features::EnhancedDataRateAcl2MbsMode => (0, 3, 1),
            Features::EnhancedDataRateAcl3MbsMode => (0, 3, 2),
            Features::EnhancedInquiryScan => (0, 3, 3),
            Features::InterlacedInquiryScan => (0, 3, 4),
            Features::InterlacedPageScan => (0, 3, 5),
            Features::RssiWithInquiryResults => (0, 3, 6),
            Features::ExtendedScoLink => (0, 3, 7),
            Features::Ev4Packets => (0, 4, 0),
            Features::Ev5Packets => (0, 4, 1),
            Features::AfhCapablePeripheral => (0, 4, 3),
            Features::AfhClassificationPeripheral => (0, 4, 4),
            Features::BrEdrNotSupported => (0, 4, 5),
            Features::LeSupportedController => (0, 4, 6),
            Features::ThreeSlotEnhancedDataRateAclPackets => (0, 4, 7),
            Features::FiveSlotEnhancedDataRateAclPackets => (0, 5, 0),
            Features::SniffSubrating => (0, 5, 1),
            Features::PauseEncryption => (0, 5, 2),
            Features::AfhCapableCentral => (0, 5, 3),
            Features::AfhClassificationCentral => (0, 5, 4),
            Features::EnhancedDataRateEsco2MbsMode => (0, 5, 5),
            Features::EnhancedDataRateEsco3MbsMode => (0, 5, 6),
            Features::ThreeSlotEnhancedDataRateEscoPackets => (0, 5, 7),
            Features::ExtendedInquiryResponse => (0, 6, 0),
            Features::SimultaneousLeAndBrEdrToSameDeviceCapable => (0, 6, 7),
            Features::SecureSimplePairingControllerSupport => (0, 6, 3),
            Features::EncapsulatedPdu => (0, 6, 4),
            Features::ErroneousDataReporting => (0, 6, 5),
            Features::NonFlushablePacketBoundaryFlag => (0, 6, 6),
            Features::LinkSupervisionTimeoutChangeEvent => (0, 7, 0),
            Features::VariableInquiryTxPowerLevel => (0, 7, 1),
            Features::EnhancedPowerControl => (0, 7, 2),
            Features::ExtendedFeatures => (0, 7, 7),
            Features::SecureSimplePairingHostSupport => (1, 0, 0),
            Features::LeSupportedHost => (1, 0, 1),
            Features::SecureConnectionsHostSupport => (1, 0, 3),
            Features::ConnectionlessPeripheralBroadcastReceiverOperation => (2, 0, 0),
            Features::ConnectionlessPeripheralBroadcastTransmissionOperation => (2, 0, 1),
            Features::SynchronizationTrain => (2, 0, 2),
            Features::SynchronizationScan => (2, 0, 3),
            Features::InquiryResponseNotificationEvent => (2, 0, 4),
            Features::GeneralizedInterlacedScan => (2, 0, 5),
            Features::CoarseClockAdjustment => (2, 0, 6),
            Features::SecureConnectionsControllerSupport => (2, 1, 0),
            Features::Ping => (2, 1, 1),
            Features::SlotAvailabilityMask => (2, 1, 2),
            Features::TrainNudging => (2, 1, 3),
        }
    }
}

impl Display for Features {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        match self {
            Features::ThreeSlotPackets => f.write_str("3 slot packets"),
            Features::FiveSlotPackets => f.write_str("5 slot packets"),
            Features::Encryption => f.write_str("encryption"),
            Features::SlotOffset => f.write_str("slot offset"),
            Features::TimingAccuracy => f.write_str("timing accuracy"),
            Features::RoleSwitch => f.write_str("role switch"),
            Features::HoldMode => f.write_str("hold mode"),
            Features::SniffMode => f.write_str("sniff mode"),
            Features::PowerControlRequests => f.write_str("power control requests"),
            Features::ChannelQualityDrivenDataRate => f.write_str("channel quality driven data rate (CQDDR)"),
            Features::ScoLink => f.write_str("SCO link"),
            Features::Hv2Packets => f.write_str("HV2 packets"),
            Features::Hv3Packets => f.write_str("HV3 packets"),
            Features::MuLawLogSynchronousData => f.write_str("Î¼-law log synchronous data"),
            Features::ALawLogSynchronousData => f.write_str("A-law log synchronous data"),
            Features::CvsdSynchronousData => f.write_str("CVSD synchronous data"),
            Features::PagingParameterNegotiation => f.write_str("paging parameter negotiation"),
            Features::PowerControl => f.write_str("power control"),
            Features::TransparentSynchronousData => f.write_str("transparent synchronous data"),
            // the value for `FlowControlLag` is units of 256 bytes
            Features::FlowControlLag(val) => write!(f, "flow control lag ({} bytes)", (*val as usize) * 256),
            Features::BroadcastEncryption => f.write_str("broadcast encryption"),
            Features::EnhancedDataRateAcl2MbsMode => f.write_str("enhanced data rate ACL 2 mbs mode"),
            Features::EnhancedDataRateAcl3MbsMode => f.write_str("enhanced data rate ACL 3 mbs mode"),
            Features::EnhancedInquiryScan => f.write_str("enhanced inquiry scan"),
            Features::InterlacedInquiryScan => f.write_str("interlaced inquiry scan"),
            Features::InterlacedPageScan => f.write_str("interlaced page scan"),
            Features::RssiWithInquiryResults => f.write_str("RSSI with inquiry results"),
            Features::ExtendedScoLink => f.write_str("extended SCO link (EV3 packets)"),
            Features::Ev4Packets => f.write_str("EV4 packets"),
            Features::Ev5Packets => f.write_str("EV5 packets"),
            Features::AfhCapablePeripheral => f.write_str("AFH capable peripheral"),
            Features::AfhClassificationPeripheral => f.write_str("AFH classification peripheral"),
            Features::BrEdrNotSupported => f.write_str("BR/EDR not supported"),
            Features::LeSupportedController => f.write_str("LE supported controller"),
            Features::ThreeSlotEnhancedDataRateAclPackets => f.write_str("3-slot enhanced data rate ACL packets"),
            Features::FiveSlotEnhancedDataRateAclPackets => f.write_str("5-slot enhanced data rate ACL packets"),
            Features::SniffSubrating => f.write_str("sniff subrating"),
            Features::PauseEncryption => f.write_str("pause encryption"),
            Features::AfhCapableCentral => f.write_str("afh capable central"),
            Features::AfhClassificationCentral => f.write_str("AFH classification central"),
            Features::EnhancedDataRateEsco2MbsMode => f.write_str("enhanced data rate eSCO 2 mbs mode"),
            Features::EnhancedDataRateEsco3MbsMode => f.write_str("enhanced data rate eSCO 3 mbs mode"),
            Features::ThreeSlotEnhancedDataRateEscoPackets => f.write_str("3-slot enhanced data rate eSCO packets"),
            Features::ExtendedInquiryResponse => f.write_str("extended inquiry response"),
            Features::SimultaneousLeAndBrEdrToSameDeviceCapable => {
                f.write_str("simultaneous LE and BR/EDR to same device capable (controller)")
            }
            Features::SecureSimplePairingControllerSupport => f.write_str("secure simple pairing (controller support)"),
            Features::EncapsulatedPdu => f.write_str("encapsulated PDU"),
            Features::ErroneousDataReporting => f.write_str("erroneous data reporting"),
            Features::NonFlushablePacketBoundaryFlag => f.write_str("non-flushable packet boundary flag"),
            Features::LinkSupervisionTimeoutChangeEvent => f.write_str("link supervision timeout change event"),
            Features::VariableInquiryTxPowerLevel => f.write_str("variable inquiry TX power level"),
            Features::EnhancedPowerControl => f.write_str("enhanced power control"),
            Features::ExtendedFeatures => f.write_str("extended features"),
            Features::SecureSimplePairingHostSupport => f.write_str("secure simple pairing (host support)"),
            Features::LeSupportedHost => f.write_str("le supported host"),
            Features::SecureConnectionsHostSupport => f.write_str("secure connections (host support)"),
            Features::ConnectionlessPeripheralBroadcastReceiverOperation => {
                f.write_str("connectionless peripheral broadcast - receiver operation")
            }
            Features::ConnectionlessPeripheralBroadcastTransmissionOperation => {
                f.write_str("connectionless peripheral broadcast - transmission operation")
            }
            Features::SynchronizationTrain => f.write_str("synchronization train"),
            Features::SynchronizationScan => f.write_str("synchronization scan"),
            Features::InquiryResponseNotificationEvent => f.write_str("HCI_Inquiry_Response_Notification event"),
            Features::GeneralizedInterlacedScan => f.write_str("generalized interlaced scan"),
            Features::CoarseClockAdjustment => f.write_str("coarse clock adjustment"),
            Features::SecureConnectionsControllerSupport => f.write_str("secure connections (controller support)"),
            Features::Ping => f.write_str("ping"),
            Features::SlotAvailabilityMask => f.write_str("slot availability mask"),
            Features::TrainNudging => f.write_str("train nudging"),
        }
    }
}

/// The features page
///
/// This is used by [`FeaturesIter`] so that it can own
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
enum FeaturesPage {
    Page0([u8; Features::PAGE_0_SIZE]),
    Page1([u8; Features::PAGE_1_SIZE]),
    Page2([u8; Features::PAGE_2_SIZE]),
}

/// Features of a device
///
/// This is a *page* of LMP features enabled by a device.
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub struct DeviceFeatures {
    features_page: FeaturesPage,
}

impl DeviceFeatures {
    /// Create a new `FeaturesIter`
    ///
    /// Input `page` is the page number of the bit map `features`.
    pub fn new(page: usize, features: &[u8]) -> Result<Self, usize> {
        macro_rules! copy_page {
            ($flags:expr, $byte_count:expr) => {{
                let mut buffer = [0u8; $byte_count];

                buffer.copy_from_slice(&$flags[..$byte_count]);

                buffer
            }};
        }

        let features_page = match page {
            0 => FeaturesPage::Page0(copy_page!(features, Features::PAGE_0_SIZE)),
            1 => FeaturesPage::Page1(copy_page!(features, Features::PAGE_1_SIZE)),
            2 => FeaturesPage::Page2(copy_page!(features, Features::PAGE_2_SIZE)),
            _ => return Err(page),
        };

        Ok(DeviceFeatures { features_page })
    }

    /// Get the page of the features
    pub fn page(&self) -> usize {
        match self.features_page {
            FeaturesPage::Page0(_) => 0,
            FeaturesPage::Page1(_) => 1,
            FeaturesPage::Page2(_) => 2,
        }
    }

    /// Check if a feature is enabled
    pub fn check(&self, feature: Features) -> bool {
        let (page, index, bit) = feature.position();

        (page == self.page())
            .then(|| match &self.features_page {
                FeaturesPage::Page0(features) => features as &[u8],
                FeaturesPage::Page1(features) => features,
                FeaturesPage::Page2(features) => features,
            })
            .and_then(|features| Features::check_by_pos(page, index, bit, features))
            .is_some()
    }

    /// Iterate over the enabled features
    pub fn iter(&self) -> FeaturesIter<'_> {
        let size = match self.features_page {
            FeaturesPage::Page0(_) => Features::PAGE_0_SIZE,
            FeaturesPage::Page1(_) => Features::PAGE_1_SIZE,
            FeaturesPage::Page2(_) => Features::PAGE_2_SIZE,
        };

        FeaturesIter::new(size, self)
    }
}

impl Display for DeviceFeatures {
    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
        match &self.features_page {
            FeaturesPage::Page0(_) => f.write_str("default LMP features:")?,
            FeaturesPage::Page1(_) => f.write_str("extended LMP features page 1 (host features):")?,
            FeaturesPage::Page2(_) => f.write_str("extended LMP features page 2:")?,
        };

        if f.alternate() {
            self.iter().try_for_each(|feature| writeln!(f, "    {}", feature))
        } else {
            let mut iter = self.iter();

            iter.next().map(|first| write!(f, " {}", first)).transpose()?;

            self.iter().try_for_each(|feature| write!(f, ", {}", feature))
        }
    }
}

/// An iterator over byte and bit positions
///
/// This iterator returns a tuple after each iteration containing a byte value and a bit value. This
/// is used as part of the iteration procedure for enabled features.
///
/// # Panic
/// This will run forever and eventually panic when self.byte > <usize>::MAX
#[derive(Debug)]
struct PositionIter {
    byte: usize,
    bit: usize,
    byte_count: usize,
}

impl PositionIter {
    /// Create a `PositionIter`
    ///
    /// Input `byte_count` is the upper bound on the iterated byte value. The byte value will
    /// increase up to `byte_count` as `PositionIter` is iterated, but once it reaches it further
    /// iterations will return `None`.
    fn new(byte_count: usize) -> Self {
        let byte = 0;
        let bit = 0;

        PositionIter { byte, bit, byte_count }
    }
}

impl Iterator for PositionIter {
    type Item = (usize, usize);

    fn next(&mut self) -> Option<Self::Item> {
        if self.byte == self.byte_count {
            return None;
        }

        let current_byte = self.byte;
        let current_bit = self.bit;

        if (self.bit + 1) > 8 {
            self.byte += 1;
            self.bit = 0;
        } else {
            self.bit += 1;
        }

        Some((current_byte, current_bit))
    }
}

/// Iterator over the [`Features`] within [`DeviceFeatures`]
///
/// This is returned by the method [`iter`] of `DeviceFeatures`.
///
/// [`iter`]: DeviceFeatures::iter
#[derive(Debug)]
pub struct FeaturesIter<'a> {
    position: PositionIter,
    device_features: &'a DeviceFeatures,
}

impl<'a> FeaturesIter<'a> {
    fn new(page_size: usize, device_features: &'a DeviceFeatures) -> Self {
        let position = PositionIter::new(page_size);

        Self {
            position,
            device_features,
        }
    }
}

impl Iterator for FeaturesIter<'_> {
    type Item = Features;

    fn next(&mut self) -> Option<Self::Item> {
        let (flags, page): (&[u8], _) = match &self.device_features.features_page {
            FeaturesPage::Page0(flags) => (flags, 0),
            FeaturesPage::Page1(flags) => (flags, 1),
            FeaturesPage::Page2(flags) => (flags, 2),
        };

        for (byte, bit) in &mut self.position {
            match Features::check_by_pos(page, byte, bit, flags) {
                feature @ Some(_) => return feature,
                None => {}
            }
        }

        None
    }
}

/// The list of LE Device Features
///
/// This is the list of device features used by a LE Controller. They can be found within volume 6,
/// part B, section 4.6 of the Bluetooth Core Specification.
#[derive(Clone, Copy, Eq, PartialEq, Debug, Ord, PartialOrd, Hash)]
pub enum LeFeatures {
    LeEncryption,
    ConnectionParametersRequestProcedure,
    ExtendedRejectIndication,
    PeripheralInitiatedFeaturesExchange,
    LePing,
    LeDataPacketLengthExtension,
    LlPrivacy,
    ExtendedScannerFilterPolicies,
    Le2MPhy,
    StableModulationIndexTransmitter,
    StableModulationIndexReceiver,
    LeCodedPhy,
    LeExtendedAdvertising,
    LePeriodicAdvertising,
    ChannelSelectionAlgorithm2,
    LePowerClass1,
    MinimumNumberOfUsedChannelsProcedure,
    ConnectionCteRequest,
    ConnectionCteResponse,
    ConnectionCteTransmitter,
    ConnectionCteReceiver,
    AntennaSwitchingDuringCteTransmission,
    AntennaSwitchingDuringCteReception,
    ReceivingConstantToneExtensions,
    PeriodicAdvertisingSyncTransferSender,
    PeriodicAdvertisingSyncTransferRecipient,
    SleepClockAccuracyUpdates,
    RemotePublicKeyValidation,
    ConnectedIsochronousStreamCentral,
    ConnectedIsochronousStreamPeripheral,
    IsochronousBroadcaster,
    SynchronizedReceiver,
}

impl LeFeatures {
    /// Check if a feature is enabled within a bit map
    ///
    /// This checks if this feature was enabled within the bit map `features`.
    pub fn check_within(self, features: &[u8]) -> bool {
        let (byte, bit) = match self {
            LeFeatures::LeEncryption => (0, 0),
            LeFeatures::ConnectionParametersRequestProcedure => (0, 1),
            LeFeatures::ExtendedRejectIndication => (0, 2),
            LeFeatures::PeripheralInitiatedFeaturesExchange => (0, 3),
            LeFeatures::LePing => (0, 4),
            LeFeatures::LeDataPacketLengthExtension => (0, 5),
            LeFeatures::LlPrivacy => (0, 6),
            LeFeatures::ExtendedScannerFilterPolicies => (0, 7),
            LeFeatures::Le2MPhy => (1, 0),
            LeFeatures::StableModulationIndexTransmitter => (1, 1),
            LeFeatures::StableModulationIndexReceiver => (1, 2),
            LeFeatures::LeCodedPhy => (1, 3),
            LeFeatures::LeExtendedAdvertising => (1, 4),
            LeFeatures::LePeriodicAdvertising => (1, 5),
            LeFeatures::ChannelSelectionAlgorithm2 => (1, 6),
            LeFeatures::LePowerClass1 => (1, 7),
            LeFeatures::MinimumNumberOfUsedChannelsProcedure => (2, 0),
            LeFeatures::ConnectionCteRequest => (2, 1),
            LeFeatures::ConnectionCteResponse => (2, 2),
            LeFeatures::ConnectionCteTransmitter => (2, 3),
            LeFeatures::ConnectionCteReceiver => (2, 4),
            LeFeatures::AntennaSwitchingDuringCteTransmission => (2, 5),
            LeFeatures::AntennaSwitchingDuringCteReception => (2, 6),
            LeFeatures::ReceivingConstantToneExtensions => (2, 7),
            LeFeatures::PeriodicAdvertisingSyncTransferSender => (3, 0),
            LeFeatures::PeriodicAdvertisingSyncTransferRecipient => (3, 1),
            LeFeatures::SleepClockAccuracyUpdates => (3, 2),
            LeFeatures::RemotePublicKeyValidation => (3, 3),
            LeFeatures::ConnectedIsochronousStreamCentral => (3, 4),
            LeFeatures::ConnectedIsochronousStreamPeripheral => (3, 5),
            LeFeatures::IsochronousBroadcaster => (3, 6),
            LeFeatures::SynchronizedReceiver => (3, 7),
        };

        Self::check_by_pos_raw(byte, bit, features).is_some()
    }

    /// Check by position for a feature within a bit map of LE features.
    ///
    /// This is used to check if a LE feature is enabled within the bit map `features`.
    ///
    /// If the `position` is valid and the bit at that position is one, then the corresponding LE
    /// feature is returned.
    ///
    /// Method [`check_within`] is much easier to use and should be used over `check_by_pos`.
    ///
    /// # Note
    /// `None` is returned if `position` is larger than the bit count of features.
    ///
    /// [`check_within`]: LeFeatures::check_within
    pub fn check_by_pos(position: usize, features: &[u8]) -> Option<Self> {
        Self::check_by_pos_raw(position >> 3, position & 0xF, features)
    }

    /// Inner method of `check_by_pos`
    ///
    /// This is the same as [`check_by_pos`] except the `byte` and `bit` are calculated from the bit
    /// position already.
    fn check_by_pos_raw(byte: usize, bit: usize, features: &[u8]) -> Option<Self> {
        match (byte, bit) {
            (0, 0) => is_bit_set!(features, (0, 0), LeFeatures::LeEncryption),
            (0, 1) => is_bit_set!(features, (0, 1), LeFeatures::ConnectionParametersRequestProcedure),
            (0, 2) => is_bit_set!(features, (0, 2), LeFeatures::ExtendedRejectIndication),
            (0, 3) => is_bit_set!(features, (0, 3), LeFeatures::PeripheralInitiatedFeaturesExchange),
            (0, 4) => is_bit_set!(features, (0, 4), LeFeatures::LePing),
            (0, 5) => is_bit_set!(features, (0, 5), LeFeatures::LeDataPacketLengthExtension),
            (0, 6) => is_bit_set!(features, (0, 6), LeFeatures::LlPrivacy),
            (0, 7) => is_bit_set!(features, (0, 7), LeFeatures::ExtendedScannerFilterPolicies),
            (1, 0) => is_bit_set!(features, (1, 0), LeFeatures::Le2MPhy),
            (1, 1) => is_bit_set!(features, (1, 1), LeFeatures::StableModulationIndexTransmitter),
            (1, 2) => is_bit_set!(features, (1, 2), LeFeatures::StableModulationIndexReceiver),
            (1, 3) => is_bit_set!(features, (1, 3), LeFeatures::LeCodedPhy),
            (1, 4) => is_bit_set!(features, (1, 4), LeFeatures::LeExtendedAdvertising),
            (1, 5) => is_bit_set!(features, (1, 5), LeFeatures::LePeriodicAdvertising),
            (1, 6) => is_bit_set!(features, (1, 6), LeFeatures::ChannelSelectionAlgorithm2),
            (1, 7) => is_bit_set!(features, (1, 7), LeFeatures::LePowerClass1),
            (2, 0) => is_bit_set!(features, (2, 0), LeFeatures::MinimumNumberOfUsedChannelsProcedure),
            (2, 1) => is_bit_set!(features, (2, 1), LeFeatures::ConnectionCteRequest),
            (2, 2) => is_bit_set!(features, (2, 2), LeFeatures::ConnectionCteResponse),
            (2, 3) => is_bit_set!(features, (2, 3), LeFeatures::ConnectionCteTransmitter),
            (2, 4) => is_bit_set!(features, (2, 4), LeFeatures::ConnectionCteReceiver),
            (2, 5) => is_bit_set!(features, (2, 5), LeFeatures::AntennaSwitchingDuringCteTransmission),
            (2, 6) => is_bit_set!(features, (2, 6), LeFeatures::AntennaSwitchingDuringCteReception),
            (2, 7) => is_bit_set!(features, (2, 7), LeFeatures::ReceivingConstantToneExtensions),
            (3, 0) => is_bit_set!(features, (3, 0), LeFeatures::PeriodicAdvertisingSyncTransferSender),
            (3, 1) => is_bit_set!(features, (3, 1), LeFeatures::PeriodicAdvertisingSyncTransferRecipient),
            (3, 2) => is_bit_set!(features, (3, 2), LeFeatures::SleepClockAccuracyUpdates),
            (3, 3) => is_bit_set!(features, (3, 3), LeFeatures::RemotePublicKeyValidation),
            (3, 4) => is_bit_set!(features, (3, 4), LeFeatures::ConnectedIsochronousStreamCentral),
            (3, 5) => is_bit_set!(features, (3, 5), LeFeatures::ConnectedIsochronousStreamPeripheral),
            (3, 6) => is_bit_set!(features, (3, 6), LeFeatures::IsochronousBroadcaster),
            (3, 7) => is_bit_set!(features, (3, 7), LeFeatures::SynchronizedReceiver),
            _ => None,
        }
    }
}

impl Display for LeFeatures {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        match self {
            LeFeatures::LeEncryption => f.write_str("LE encryption"),
            LeFeatures::ConnectionParametersRequestProcedure => f.write_str("connection parameters request procedure"),
            LeFeatures::ExtendedRejectIndication => f.write_str("extended reject indication"),
            LeFeatures::PeripheralInitiatedFeaturesExchange => f.write_str("peripheral initiated features exchange"),
            LeFeatures::LePing => f.write_str("LE ping"),
            LeFeatures::LeDataPacketLengthExtension => f.write_str("LE data packet length extension"),
            LeFeatures::LlPrivacy => f.write_str("LL privacy"),
            LeFeatures::ExtendedScannerFilterPolicies => f.write_str("extended scanner filter policies"),
            LeFeatures::Le2MPhy => f.write_str("LE 2M phy"),
            LeFeatures::StableModulationIndexTransmitter => f.write_str("stable modulation index transmitter"),
            LeFeatures::StableModulationIndexReceiver => f.write_str("stable modulation index receiver"),
            LeFeatures::LeCodedPhy => f.write_str("LE coded phy"),
            LeFeatures::LeExtendedAdvertising => f.write_str("LE extended advertising"),
            LeFeatures::LePeriodicAdvertising => f.write_str("LE periodic advertising"),
            LeFeatures::ChannelSelectionAlgorithm2 => f.write_str("channel selection algorithm2"),
            LeFeatures::LePowerClass1 => f.write_str("LE power class1"),
            LeFeatures::MinimumNumberOfUsedChannelsProcedure => {
                f.write_str("minimum number of used channels procedure")
            }
            LeFeatures::ConnectionCteRequest => f.write_str("connection CTE request"),
            LeFeatures::ConnectionCteResponse => f.write_str("connection CTE response"),
            LeFeatures::ConnectionCteTransmitter => f.write_str("connection CTE transmitter"),
            LeFeatures::ConnectionCteReceiver => f.write_str("connection CTE receiver"),
            LeFeatures::AntennaSwitchingDuringCteTransmission => {
                f.write_str("antenna switching during CTE transmission")
            }
            LeFeatures::AntennaSwitchingDuringCteReception => f.write_str("antenna switching during cte reception"),
            LeFeatures::ReceivingConstantToneExtensions => f.write_str("receiving constant tone extensions"),
            LeFeatures::PeriodicAdvertisingSyncTransferSender => {
                f.write_str("periodic advertising sync transfer sender")
            }
            LeFeatures::PeriodicAdvertisingSyncTransferRecipient => {
                f.write_str("periodic advertising sync transfer recipient")
            }
            LeFeatures::SleepClockAccuracyUpdates => f.write_str("sleep clock accuracy updates"),
            LeFeatures::RemotePublicKeyValidation => f.write_str("remote public key validation"),
            LeFeatures::ConnectedIsochronousStreamCentral => f.write_str("connected isochronous stream central"),
            LeFeatures::ConnectedIsochronousStreamPeripheral => f.write_str("connected isochronous stream peripheral"),
            LeFeatures::IsochronousBroadcaster => f.write_str("isochronous broadcaster"),
            LeFeatures::SynchronizedReceiver => f.write_str("synchronized receiver"),
        }
    }
}

/// The LE Features of a device
///
/// This is the LE features enabled by a device.
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub struct LeDeviceFeatures {
    bit_mask: [u8; 8],
}

impl LeDeviceFeatures {
    /// Create a new `LeDeviceFeatures`
    ///
    /// This will create a new `LeDeviceFeatures` if the length of `features` is eight. Otherwise it
    /// will return an error with the length of `features`.
    pub fn new(features: &[u8]) -> Result<Self, usize> {
        if features.len() == 8 {
            let mut bit_mask = [0u8; 8];

            bit_mask.copy_from_slice(features);

            Ok(LeDeviceFeatures { bit_mask })
        } else {
            Err(features.len())
        }
    }

    /// Check if a LE feature is enabled
    pub fn contains(&self, feature: &LeFeatures) -> bool {
        feature.check_within(&self.bit_mask)
    }

    /// Iterate over the enabled features
    pub fn iter(&self) -> LeFeaturesItr<'_> {
        LeFeaturesItr::new(self)
    }
}

impl Display for LeDeviceFeatures {
    fn fmt(&self, f: &mut Formatter) -> core::fmt::Result {
        f.write_str("LE device features:")?;

        if f.alternate() {
            self.iter().try_for_each(|feature| writeln!(f, "    {}", feature))
        } else {
            let mut iter = self.iter();

            iter.next().map(|first| write!(f, " {}", first)).transpose()?;

            self.iter().try_for_each(|feature| write!(f, ", {}", feature))
        }
    }
}

/// Iterator over enabled LE features
///
/// This is returned by the method [`LeDeviceFeatures::iter`].
#[derive(Debug)]
pub struct LeFeaturesItr<'a> {
    position: PositionIter,
    le_device_features: &'a LeDeviceFeatures,
}

impl<'a> LeFeaturesItr<'a> {
    const MAX_LE_FEATURE_POSITION: usize = 39;

    /// Create a `LeFeaturesItr`
    fn new(le_device_features: &'a LeDeviceFeatures) -> Self {
        let position = PositionIter::new((Self::MAX_LE_FEATURE_POSITION >> 3) + 1);

        Self {
            position,
            le_device_features,
        }
    }
}

impl Iterator for LeFeaturesItr<'_> {
    type Item = LeFeatures;

    fn next(&mut self) -> Option<Self::Item> {
        for (byte, bit) in &mut self.position {
            match LeFeatures::check_by_pos_raw(byte, bit, &self.le_device_features.bit_mask) {
                feature @ Some(_) => return feature,
                None => (),
            }
        }

        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn invalid_static_device_address() {
        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsZero),
            BluetoothDeviceAddress::try_from_static_random([0; 6])
        );

        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_static_random([0xFF; 6])
        );

        assert_eq!(
            Err(errors::StaticDeviceError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_static_random([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F])
        )
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn invalid_non_resolvable_private_address() {
        assert_eq!(
            Err(errors::NonResolvableError::AddressIsZero),
            BluetoothDeviceAddress::try_from_non_resolvable([0; 6])
        );

        assert_eq!(
            Err(errors::NonResolvableError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_non_resolvable([0xFF; 6])
        );

        assert_eq!(
            Err(errors::NonResolvableError::AddressIsAllOnes),
            BluetoothDeviceAddress::try_from_non_resolvable([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F])
        );
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn invalid_resolvable_private_address() {
        let irk = 1234u128;

        assert_eq!(
            Err(errors::ResolvableError::PRandIsZero),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0; 3])
        );

        assert_eq!(
            Err(errors::ResolvableError::PRandIsAllOnes),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0xFF; 3])
        );

        assert_eq!(
            Err(errors::ResolvableError::PRandIsAllOnes),
            BluetoothDeviceAddress::try_from_resolvable(irk, [0xFF, 0xFF, 0x3F])
        );
    }

    #[cfg(feature = "cryptography")]
    #[test]
    fn resolve_resolvable_private_address() {
        let irk = 123456u128;

        let p_rand = [0x12, 0x23, 0x34];

        let rpa = BluetoothDeviceAddress::try_from_resolvable(irk, p_rand).unwrap();

        assert!(rpa.resolve(irk));
    }

    #[test]
    fn bluetooth_addr_ui_representation() {
        assert_eq!(
            Ok(BluetoothDeviceAddress([0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12])),
            BluetoothDeviceAddress::try_from("123456789abc")
        );

        assert_eq!(
            Ok(BluetoothDeviceAddress([0xbc, 0x9a, 0x78, 0x56, 0x34, 0x12])),
            BluetoothDeviceAddress::try_from("12:34:56:78:9a:bc")
        );

        // The Bluetooth Specification does not have a common format
        // when using colons to split an address into sub-slices. This
        // might be shown in a UI where the address is split into the
        // LAP, UAP, and NAP parts.
        assert_eq!(
            Ok(BluetoothDeviceAddress([0x56, 0x34, 0x12, 0xef, 0xcd, 0xab])),
            BluetoothDeviceAddress::try_from("abcdef:12:3456")
        );

        // Repetitions of colons are not allowed.
        assert_eq!(
            Err(BluetoothDeviceAddress::REPEATED_COLONS),
            BluetoothDeviceAddress::try_from("ab::cd::ef::12::34::56")
        );

        // Colon(s) at the front are not allowed
        assert_eq!(
            Err(BluetoothDeviceAddress::COLON_AT_FRONT),
            BluetoothDeviceAddress::try_from(":abcdef123456")
        );

        // Colon(s) at the back are not allowed
        assert_eq!(
            Err(BluetoothDeviceAddress::COLON_AT_BACK),
            BluetoothDeviceAddress::try_from("abcdef123456:")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::INVALID_CHARS),
            BluetoothDeviceAddress::try_from("hello_worlds")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_MANY_CHARS),
            BluetoothDeviceAddress::try_from("123456789abcd")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_FEW_CHARS),
            BluetoothDeviceAddress::try_from("123456789ab")
        );

        assert_eq!(
            Err(BluetoothDeviceAddress::TOO_FEW_CHARS),
            BluetoothDeviceAddress::try_from("123456789a")
        );
    }
}
