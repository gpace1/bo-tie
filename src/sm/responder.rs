
use super::*;

pub struct SlaveSecurityManagerBuilder<'a, HCI, C> {
    sm: &'a SecurityManager,
    hci: &'a HostInterface<HCI>,
    connection_channel: &'a C,
    io_capabilities: pairing::IOCapability,
    oob_data: Option<u128>,
    encryption_key_min: usize,
    encryption_key_max: usize,
    remote_address: &'a crate::BluetoothDeviceAddress,
    this_address: &'a crate::BluetoothDeviceAddress,
    remote_address_is_random: bool,
    this_address_is_random: bool,
}

impl<'a,HCI,C> SlaveSecurityManagerBuilder<'a,HCI,C>
    where HCI: HostControllerInterface,
          C: ConnectionChannel,
{
    pub(super) fn new(
        sm: &'a SecurityManager,
        hci: &'a HostInterface<HCI>,
        connection_channel: &'a C,
        connected_device_address: &'a crate::BluetoothDeviceAddress,
        this_device_address: &'a crate::BluetoothDeviceAddress,
        is_connected_devices_address_random: bool,
        is_this_device_address_random: bool,
    ) -> Self {
        Self {
            sm,
            hci,
            connection_channel,
            io_capabilities: pairing::IOCapability::NoInputNoOutput,
            oob_data: None,
            encryption_key_min: ENCRYPTION_KEY_MIN_SIZE,
            encryption_key_max: ENCRYPTION_KEY_MAX_SIZE,
            remote_address: connected_device_address,
            this_address: this_device_address,
            remote_address_is_random: is_connected_devices_address_random,
            this_address_is_random: is_this_device_address_random,
        }
    }

    /// Set the minimum and maximum encryption key size
    ///
    /// min >= 7, max <= 16, and `min` <= `max`
    pub fn set_min_and_max_encryption_key_size(mut self, min: usize, max: usize) -> Result<Self, ()> {
        if (min >= 7) && (max <= 16) && (min <= max) {
            self.encryption_key_min = min;
            self.encryption_key_max = max;
            Ok(self)
        } else {
            Err(())
        }
    }

    /// Set the 128 bit random number that was shared between two devices over some 'out of band'
    /// way.
    pub fn set_oob_data(mut self, temp_key: u128) -> Self {
        self.oob_data = temp_key.into();
        self
    }

    pub fn create_security_manager(&self) -> SlaveSecurityManager<'a, HCI, C> {

        let auth_req = alloc::vec![
            encrypt_info::AuthRequirements::Bonding,
            encrypt_info::AuthRequirements::ManInTheMiddleProtection,
        ];

        let key_dist = alloc::vec![
            pairing::KeyDistributions::IdKey,
        ];

        SlaveSecurityManager {
            sm: self.sm,
            hci: &self.hci,
            connection_channel: self.connection_channel,
            io_capability: self.io_capabilities,
            oob_data: self.oob_data,
            passkey: None,
            encryption_key_size_min: self.encryption_key_min,
            encryption_key_size_max: self.encryption_key_max,
            auth_req,
            initiator_key_distribution: key_dist.clone(),
            responder_key_distribution: key_dist,
            initiator_address: self.remote_address,
            responder_address: self.this_address,
            initiator_address_is_random: self.remote_address_is_random,
            responder_address_is_random: self.this_address_is_random,
            pairing_data: None,
        }
    }
}

/// Data that is gathered in the process of pairing
///
/// This data is unique for each pairing attempt and must be dropped after a successful or failed
/// pairing attempt.
struct PairingData {
    /// The current pairing method
    key_gen_method: KeyGenerationMethod,
    /// The temporary public key generated by this device
    temp_public_key: [u8;64],
    /// The temporary private key generated by this device
    temp_private_key: [u8;32],
    /// initiator IO Capabilities information
    remote_io_cap: [u8;3],
    /// Nonce value
    ///
    /// This will change multiple times for passkey, but is static for just works or number
    /// comparison
    nonce: u128,
    /// Calculated Diffie-Hellman (shared) Key
    dh_key: Option<[u8;32]>,
    /// The public key received from the remote device
    remote_pub_temp_key: Option<[u8;64]>,
    /// The remote nonce
    ///
    /// This will change multiple times for passkey, but is static for just works or number
    /// comparison
    remote_nonce: Option<u128>,
    /// The generated LTK
    ltk: Option<u128>,
    /// The generated MacKey
    mac_key: Option<u128>,
}

fn convert_io_cap(
    auth_req: &[encrypt_info::AuthRequirements],
    oob_flag: pairing::OOBDataFlag,
    io_cap: pairing::IOCapability
)
-> [u8;3]
{
    [
        io_cap.into_val(),
        oob_flag.into_val(),
        encrypt_info::AuthRequirements::make_auth_req_val(auth_req),
    ]
}

pub struct SlaveSecurityManager<'a, HCI, C> {
    sm: &'a SecurityManager,
    hci: &'a HostInterface<HCI>,
    connection_channel: &'a C,
    io_capability: pairing::IOCapability,
    oob_data: Option<u128>,
    passkey: Option<u32>,
    auth_req: Vec<encrypt_info::AuthRequirements>,
    encryption_key_size_min: usize,
    encryption_key_size_max: usize,
    initiator_key_distribution: Vec<pairing::KeyDistributions>,
    responder_key_distribution: Vec<pairing::KeyDistributions>,
    initiator_address: &'a crate::BluetoothDeviceAddress,
    responder_address: &'a crate::BluetoothDeviceAddress,
    initiator_address_is_random: bool,
    responder_address_is_random: bool,
    pairing_data: Option<PairingData>
}

impl<'a, HCI, C> SlaveSecurityManager<'a, HCI, C>
    where HCI: HostControllerInterface,
          C: ConnectionChannel,
{

    pub fn set_oob_data(&mut self, val: u128) { self.oob_data = Some(val) }

    /// Process a request from a MasterSecurityManager
    ///
    /// This will return a response to a valid request that can be sent to the Master device.
    /// Errors will be returned if the request is not something that can be processed by the slave
    /// or there was something wrong with the request message.
    pub fn process_command<'z>(&'z mut self, received_data: &'z [u8] )
                               -> impl Future<Output = Result<(), Error>> + 'z
    {
        if received_data.len() > SecurityManager::SMALLEST_PACKET_SIZE {

            let (d_type, payload) = received_data.split_at(1);

            match CommandType::try_from_val(d_type[0]) {
                Ok( CommandType::PairingRequest ) => self.p_pairing_request(payload),
                Ok( CommandType::PairingConfirm ) => self.p_pairing_confirm(payload) ,
                Ok( CommandType::PairingPublicKey ) => self.p_pairing_public_key(payload),
                Ok( CommandType::PairingRandom ) => self.p_pairing_random(payload),
                Ok( CommandType::PairingFailed ) => self.p_pairing_failed(payload),
                Ok( CommandType::PairingDHKeyCheck ) => unimplemented!(),
                Ok( CommandType::EncryptionInformation ) => unimplemented!(),
                Ok( CommandType::MasterIdentification ) => unimplemented!(),
                Ok( CommandType::IdentityInformation ) => unimplemented!(),
                Ok( CommandType::IdentityAddressInformation ) => unimplemented!(),
                Ok( CommandType::SigningInformation ) => unimplemented!(),
                Ok( cmd ) => self.p_command_not_supported(cmd),
                Err( cmd ) => self.p_unknown_command(cmd),
            }

        } else {
            self.p_bad_data_len()
        }
    }

    fn send<Cmd,P>(&self, command: Cmd)
        where Cmd: Into<Command<P>>,
              P: CommandData
    {
        use crate::l2cap::AclData;

        let acl_data = AclData::new( command.into().into_icd(), SECURITY_MANAGER_L2CAP_CHANNEL_ID);

        self.connection_channel.send(acl_data);
    }

    fn send_err(&mut self, fail_reason: pairing::PairingFailedReason) {
        self.pairing_data = None;

        self.send(pairing::PairingFailed::new(pairing::PairingFailedReason::EncryptionKeySize));
    }

    fn p_bad_data_len(&mut self) -> CommandProcessFuture<'_> {
        cmd_process_future!{
            self.send_err(pairing::PairingFailedReason::UnspecifiedReason);

            Poll::Ready(Err( Error::Size ) )
        }
    }

    fn p_unknown_command(&mut self, err: Error) -> CommandProcessFuture<'_> {
        cmd_process_future!{
            self.send_err(pairing::PairingFailedReason::CommandNotSupported);

            Poll::Ready(Err(err))
        }
    }

    fn p_command_not_supported(&mut self, cmd: CommandType) -> CommandProcessFuture<'_> {
        cmd_process_future!{
            self.send_err(pairing::PairingFailedReason::CommandNotSupported);

            Poll::Ready(Err(Error::IncorrectCommand(cmd)))
        }
    }

    fn p_pairing_request<'z>(&'z mut self, data: &'z [u8]) -> CommandProcessFuture<'z> {
        cmd_process_future! {

            let request = pairing::PairingRequest::try_from_icd(data)?;

            if request.get_max_encryption_size() < self.encryption_key_size_min {
                self.send_err(pairing::PairingFailedReason::EncryptionKeySize)
            } else {

                let response = pairing::PairingResponse::new(
                    self.io_capability,
                    if self.oob_data.is_some() {
                        pairing::OOBDataFlag::AuthenticationDataFromRemoteDevicePresent
                    } else {
                        pairing::OOBDataFlag::AuthenticationDataNotPresent
                    },
                    self.auth_req.clone(),
                    self.encryption_key_size_max,
                    self.initiator_key_distribution.clone(),
                    self.responder_key_distribution.clone(),
                );

                let pairing_method = KeyGenerationMethod::determine_method(
                    request.get_oob_data_flag(),
                    response.get_oob_data_flag(),
                    request.get_io_capability(),
                    response.get_io_capability(),
                    false
                );

                let remote_io_cap = convert_io_cap(
                    request.get_auth_req(),
                    request.get_oob_data_flag(),
                    request.get_io_capability(),
                );

                self.send(response);

                let (private_key, public_key) = toolbox::ec()
                    .expect("Failed to fill bytes for generated random");

                self.pairing_data = Some(PairingData {
                    key_gen_method: pairing_method,
                    temp_public_key: public_key,
                    temp_private_key: private_key,
                    remote_io_cap,
                    nonce: toolbox::nonce(),
                    dh_key: None,
                    remote_pub_temp_key: None,
                    remote_nonce: None,
                    ltk: None,
                    mac_key: None,
                });
            };

            Poll::Ready(Ok(()))
        }
    }

    fn p_pairing_public_key<'z>(&'z mut self, data: &'z [u8]) -> CommandProcessFuture<'z> {

        cmd_process_future! {
            let initiator_pub_key = pairing::PairingPubKey::try_from_icd(data)?;

            if let Some(mut pairing_data) = self.pairing_data.take() {

                // Send the public key of this device
                self.send(pairing::PairingPubKey::new(pairing_data.temp_public_key.clone()));

                let remote_public_key = initiator_pub_key.get_key();

                // Calculate the shared secret key
                let secret_key = toolbox::ecdh(&pairing_data.temp_private_key, &remote_public_key);

                pairing_data.remote_pub_temp_key = Some(remote_public_key);

                match secret_key.ok() {
                    sk @ Some(_) => {

                        pairing_data.dh_key = sk.map(|sk| {
                            let mut k = [0u8; 32];

                            k.copy_from_slice(sk.as_ref());

                            k
                        });

                        self.pairing_data = pairing_data.into();

                        Poll::Ready( Ok(()) )
                    },
                    None => {
                        // Generating the dh key failed
                        self.send_err(pairing::PairingFailedReason::UnspecifiedReason);
                        Poll::Ready( Err(Error::IncorrectValue) )
                    }
                }

            } else {
                self.send_err(pairing::PairingFailedReason::UnspecifiedReason);

                Poll::Ready( Err(Error::IncorrectCommand(CommandType::PairingPublicKey)) )
            }
        }
    }

    fn p_pairing_confirm<'z>(&'z mut self, payload: &'z [u8]) -> CommandProcessFuture<'z> {

        cmd_process_future! {

            let initiator_confirm = pairing::PairingConfirm::try_from_icd(payload)?;

            match self.pairing_data.as_ref() {
                Some( PairingData{
                    key_gen_method: KeyGenerationMethod::JustWorks,
                    temp_public_key: this_pk,
                    remote_pub_temp_key: Some( initiator_pk ),
                    nonce,
                    ..
                }) |
                Some( PairingData{
                    key_gen_method: KeyGenerationMethod::NumbComp,
                    temp_public_key: this_pk,
                    remote_pub_temp_key: Some( initiator_pk ),
                    nonce,
                    ..
                }) => /* Legacy Just Works or LE Secure Connection Number Comparison */
                {
                    let confirm_value = toolbox::f4(this_pk.x(), initiator_pk.x(), *nonce, 0);

                    self.send(pairing::PairingConfirm::new(confirm_value));

                    Poll::Ready( Ok(()) )
                },
                // The pairing methods OOB and Passkey are not supported yet
                //
                // This is normally here for catching when the protocol is issued this command out
                // of order
                _ => {
                    self.send_err(pairing::PairingFailedReason::PairingNotSupported);

                    Poll::Ready( Err(Error::UnsupportedFeature))
                },
            }

        }
    }

    fn p_pairing_random<'z>(&'z mut self, payload: &'z [u8]) -> CommandProcessFuture<'z> {

        cmd_process_future! {
            let initiator_random = pairing::PairingRandom::try_from_icd(payload)?;

            if self.pairing_data.is_some() {

                self.pairing_data.as_mut().unwrap().remote_nonce = Some(initiator_random.get_value());

                self.send( pairing::PairingRandom::new(self.pairing_data.as_ref().unwrap().nonce) );

                Poll::Ready( Ok(()) )

            } else {
                self.send_err(pairing::PairingFailedReason::UnspecifiedReason);

                Poll::Ready( Err(Error::UnsupportedFeature))
            }
        }

    }

    fn p_pairing_failed<'z>(&'z mut self, payload: &'z [u8]) -> CommandProcessFuture<'z> {

        cmd_process_future! {
            let initiator_fail = pairing::PairingFailed::try_from_icd(payload)?;

            self.pairing_data = None;

            Poll::Ready( Err(Error::PairingFailed(initiator_fail.get_reason())) )
        }
    }

    fn p_pairing_dh_key_check<'z>(&'z mut self, payload: &'z [u8]) -> CommandProcessFuture<'z> {

        cmd_process_future! {
            let initiator_dh_key_check = pairing::PairingDHKeyCheck::try_from_icd(payload)?;

            match self.pairing_data {
                Some( PairingData {
                    dh_key: Some( dh_key ),
                    nonce: nonce,
                    remote_nonce: Some( remote_nonce ),
                    remote_io_cap: remote_io_cap,
                    ..
                }) => {

                    let init_msb_addr_byte: u8 = if self.initiator_address_is_random {1} else {0};
                    let this_msb_addr_byte: u8 = if self.responder_address_is_random {1} else {0};

                    let mut a_addr = [init_msb_addr_byte, 0, 0, 0, 0, 0, 0];
                    let mut b_addr= [this_msb_addr_byte, 0, 0, 0, 0, 0, 0];

                    a_addr[1..].copy_from_slice(self.initiator_address);
                    b_addr[1..].copy_from_slice(self.responder_address);

                    let (mac_key, ltk) = toolbox::f5(
                        dh_key,
                        remote_nonce,
                        nonce,
                        a_addr.clone(),
                        b_addr.clone(),
                    );

                    let ea = toolbox::f6(
                        mac_key,
                        remote_nonce,
                        nonce,
                        0,
                        remote_io_cap,
                        a_addr,
                        b_addr,
                    );

                    let received_ea = initiator_dh_key_check.get_key_check();

                    if received_ea == ea {

                        self.pairing_data.as_mut().unwrap().ltk = Some(ltk);

                        let eb = toolbox::f6(
                            mac_key,
                            nonce,
                            remote_nonce,
                            0,
                            convert_io_cap(
                                &self.auth_req,
                                if self.oob_data.is_some() {
                                    pairing::OOBDataFlag::AuthenticationDataFromRemoteDevicePresent
                                } else {
                                    pairing::OOBDataFlag::AuthenticationDataNotPresent
                                },
                                self.io_capability,
                            ),
                            b_addr.clone(),
                            a_addr.clone(),
                        );

                        self.send(pairing::PairingDHKeyCheck::new(eb));

                        // TODO start encryption and start key exchanging
                        Poll::Ready( Ok(()) )
                    } else {
                        self.send_err(pairing::PairingFailedReason::DHKeyCheckFailed);

                        Poll::Ready( Err(Error::PairingFailed(pairing::PairingFailedReason::DHKeyCheckFailed)) )
                    }
                }
                _ => {
                    self.send_err(pairing::PairingFailedReason::UnspecifiedReason);

                    Poll::Ready( Err(Error::UnsupportedFeature))
                }
            }
        }
    }

//    fn encrypt_link(&mut self) ->  {
//        match self.pairing_data {
//            Some( PairingData {
//                ltk: Some(ltk)
//            }) {
//
//            }
//            _ =>
//        }
//    }
}

pub struct AsyncMasterSecurityManager<'a, HCI, C> {
    sm: &'a SecurityManager,
    hci: &'a HostInterface<HCI>,
    connection_channel: &'a C,
}

impl<'a, HCI, C> AsyncMasterSecurityManager<'a, HCI, C> {
    fn new( sm: &'a SecurityManager, hci: &'a HostInterface<HCI>, connection_channel: &'a C ) -> Self {
        Self { sm, hci, connection_channel }
    }
}

pub struct AsyncSlaveSecurityManager<'a, HCI, C> {
    sm: &'a SecurityManager,
    hci: &'a HostInterface<HCI>,
    connection_channel: &'a C,
}

impl<'a, HCI, C> AsyncSlaveSecurityManager<'a, HCI, C> {
    fn new( sm: &'a SecurityManager, hci: &'a HostInterface<HCI>, connection_channel: &'a C ) -> Self {
        Self { sm, hci, connection_channel }
    }
}