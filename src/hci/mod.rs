//! In Bluez there is a "manager" for the interface to the bluetooth hardware
//!
//! This is really the api to the HCI (host controller interface) of the bluetooth device (as per
//! the bluetooth specification). This module is further broken up into modules for OGFs (OpCode
//! group field(s)).

macro_rules! hci_future_output {
    () => { ::core::result::Result<::hci::events::EventsData,impl ::core::fmt::Display + ::core::fmt::Debug> }
}

pub mod common;
pub mod error;
#[macro_use] pub mod events;

#[cfg(unix)] mod unix;

use core::time::Duration;

/// Error type for hci commands/events
#[derive(Debug,PartialEq)]
pub enum CommandError<SysErr,SpecErr>
    where SysErr  : ::core::fmt::Debug,
          SpecErr : ::core::fmt::Debug
{
    /// System specific error
    SystemError(SysErr),
    /// An error generated by the bluetooth device. The value is the status returned by the
    /// device to indicate the error. These errors are defined in the specification (v5 volume 2,
    /// part D section 2)
    HCI(error::Error),
    /// An error that is specifically related to the command
    Specific(SpecErr),
}

/// Used to get the information required for sending a command from the host to the controller
///
/// The type Parameter should be a packed structure of the command's parameters
trait CommandParameters {
    /// The command parameter to return
    type Parameter;
    /// OpCode Group Field for the command
    const OGF: u16;
    /// Command identifier (OpCode Command Field)
    const OCF: u16;

    fn get_parameter(&self) -> Self::Parameter;
}

/// This is a wrapper around the os HCI object
pub struct HostInterface {
    #[cfg(unix)]
    interface: unix::HCIAdapter,
}

/// Return type for hci commands
macro_rules! hci_return {
    () => {
        ::core::result::Result< impl ::core::future::Future <Output= hci_future_output!() >,
            CommandError < impl ::core::fmt::Debug, impl ::core::fmt::Debug> >
    }
}

impl HostInterface {

    /// Send a command to the controller
    ///
    /// The command data will be used in the command packet to determine what HCI command is sent
    /// to the controller. The events specified should be the events directly returned by the
    /// controller in response to the command, they should not be events that will come later as
    /// a timeout may occur before the event is sent from the controller.
    ///
    /// A future is returned for waiting on the specified events from the controller.
    fn send_command<CmdData>(
        &self, cmd_data: CmdData,
        event: events::Events,
        timeout: Duration
    ) -> hci_return!()
        where CmdData: CommandParameters,
    {
        self.interface.send_command(cmd_data, event, timeout ).or_else(|e| { Err(CommandError::from(e)) })
    }

    // TODO
    // /// Specify events to wait for
    // ///
    // /// This will return a future for waiting on one or more events from the controller. There is
    // /// no timeout for waiting for the events
    // fn wait_for_event(&self, events: events::Events, timeout: Duration) ->
    //     impl ::core::future::Future <Output= hci_future_output!() >
    // {
    //     self.interface.wait_for_events(events, timeout)
    // }
}

impl ::core::default::Default for HostInterface {

    #[cfg(unix)]
    fn default() -> Self {
        HostInterface { interface: unix::HCIAdapter::default() }
    }
}

/// For commands that only return a status
macro_rules! impl_status_return {
    ($ocf:expr, $ogf:expr ) => {
        pub struct Return;

        impl Return {
            fn try_from( raw: u8 ) -> Result<(), error::Error> {
                let status = error::Error::from(raw);

                if let error::Error::NoError = status {
                    Ok(())
                }
                else {
                    Err(status)
                }
            }
        }

        impl_get_data_for_command!($ocf, $ogf, u8, Return, (), error::Error);
    }
}

#[cfg(test)]
#[macro_use]
mod test_util {
    use std::future::Future;
    use std::marker::Unpin;
    use std::sync::{Arc,Mutex};

    lazy_static! {

        pub static ref TEST_EXCLUSION: Arc<Mutex<()>> = Arc::new(Mutex::new(()));
    }

    pub fn block_for_result<T> ( mut cmd_future: impl Future <Output=T> + Unpin ) -> T {
        use std::pin::Pin;
        use std::sync::Arc;
        use std::task::{LocalWaker, local_waker_from_nonlocal, Poll, Wake};
        use std::thread;

        struct SelfWaker {
            thread: thread::Thread,
        }

        impl Wake for SelfWaker {
            fn wake(arc_self: &Arc<Self>) {
                arc_self.thread.unpark();
            }
        }

        impl SelfWaker {
            fn new_local_waker() -> LocalWaker {
                local_waker_from_nonlocal(Arc::new(SelfWaker {
                    thread: thread::current()
                }))
            }
        }

        let waker = SelfWaker::new_local_waker();

        'async: loop {
            let pinned_future = Pin::new(&mut cmd_future);

            match pinned_future.poll(&waker) {
                Poll::Pending => thread::park(),
                Poll::Ready(rslt) => break 'async rslt,
            };
        }
    }

    pub fn block_for_command_result(
        cmd_future: impl Future <Output= hci_future_output!() > + Unpin )
        -> hci_future_output!()
    {
        block_for_result(cmd_future)
    }

    #[macro_use]
    macro_rules! command_complete_test {
        ( $future_return:expr, $ret_ty:ty ) => {
            match $future_return {
                events::EventsData::CommandComplete(ref data, ref raw) => {
                    let return_val = unsafe {
                        (data as &::hci::events::GetDataForCommand<$ret_ty>).get_return()
                    };

                    if let Err(e) = return_val {
                        panic!("Return Error: {:?}, Raw Data: {:?}", e, raw);
                    }

                    assert!( return_val.unwrap().is_some() );
                },
                _ => {
                    panic!("Expected Command Complete Event");
                }
            }
        };
        ( $future_return:expr, $ret_ty:ty, $exp_ret_val:expr ) => {
            match $future_return {
                events::EventsData::CommandComplete(ref data, ref raw) => {
                    let return_val = unsafe {
                        (data as &::hci::events::GetDataForCommand<$ret_ty>).get_return()
                    };

                    assert_eq!( Ok(Some($exp_ret_val)), return_val, "Raw Event data: {:?}", raw);
                },
                _ => {
                    panic!("Expected Command Complete Event");
                }
            }
        }
    }
}

#[cfg(not(no_le))]
pub mod le {

    #[macro_use]
    mod common {

        use core::convert::From;
        use core::time::Duration;

        /// The valid address types for this HCI command
        ///
        /// - PublicDeviceAddress
        ///     A bluetooth public address
        /// - RandomDeviceAddress
        ///     A bluetooth random address
        /// - DevicesSendingAnonymousAdvertisements
        ///     A device sending advertisment packets without an address
        pub enum AddressType {
            PublicDeviceAddress,
            RandomDeviceAddress,
            #[cfg(bluetooth_5_0)] DevicesSendingAnonymousAdvertisements,
        }

        impl AddressType {
            pub fn to_value(&self) -> u8 {
                match *self {
                    AddressType::PublicDeviceAddress => 0x00u8,
                    AddressType::RandomDeviceAddress => 0x01u8,
                    #[cfg(bluetooth_5_0)]
                    AddressType::DevicesSendingAnonymousAdvertisements => 0xFFu8,
                }
            }
        }

        /// Own Address Type
        ///
        /// Default is a Public Address.
        ///
        /// # Notes
        /// These are the full explanation for the last two enumerations (as copied from
        /// the core 5.0 specification):
        /// - RPAFromLocalIRKPA -> Controller generates Resolvable Private Address based on
        ///     the local IRK from the resolving list. If the resolving list contains no
        ///     matching entry, use the public address.
        /// - RPAFromLocalIRKRA -> Controller generates Resolvable Private Address based on
        ///     the local IRK from the resolving list. If the resolving list contains no
        ///     matching entry, use the random address from LE_Set_Random_Address.
        #[cfg_attr(test,derive(Debug))]
        pub enum OwnAddressType {
            PublicDeviceAddress,
            RandomDeviceAddress,
            RPAFromLocalIRKPA,
            RPAFromLocalIRKRA,
        }

        impl OwnAddressType {
            pub(super) fn into_val(&self) -> u8 {
                match *self {
                    OwnAddressType::PublicDeviceAddress => 0x00,
                    OwnAddressType::RandomDeviceAddress => 0x01,
                    OwnAddressType::RPAFromLocalIRKPA => 0x02,
                    OwnAddressType::RPAFromLocalIRKRA => 0x03,
                }
            }
        }

        impl Default for OwnAddressType {
            fn default() -> Self {
                OwnAddressType::PublicDeviceAddress
            }
        }

        #[cfg_attr(test,derive(Debug))]
        pub struct Frequency {
            val: u8
        }

        impl Frequency {
            /// Maximum frequency value
            pub const MAX: usize = 2480;

            /// Minimum frequency value
            pub const MIN: usize = 2402;

            /// Creates a new Frequency object
            ///
            /// The value (N) passed to the adapter follows the following equation:
            ///
            /// # Error
            /// The value is less then MIN or greater than MAX. MIN or MAX is returned
            /// depending on which bound is violated.
            pub fn new( mega_hz: usize ) -> Result<Frequency, usize> {
                if mega_hz < Frequency::MIN {
                    Err(Frequency::MIN)
                }
                else if mega_hz > Frequency::MAX {
                    Err(Frequency::MAX)
                }
                else {
                    Ok(Frequency{ val: ((mega_hz - 2402) / 2) as u8})
                }
            }

            pub(in super::super) fn get_val(&self) -> u8 { self.val }
        }

        pub struct AdvIntRng<T> where T: PartialEq + PartialOrd {
            pub low: T,
            pub hi: T,
            pub micro_sec_conv: u64,
        }

        impl<T> AdvIntRng<T> where T: PartialEq + PartialOrd {

            pub fn contains(&self, val: &T ) -> bool {
                self.low <= *val && *val <= self.hi
            }
        }

        impl From<AdvIntRng<u16>> for AdvIntRng<Duration> {
            fn from( raw: AdvIntRng<u16> ) -> Self {
                AdvIntRng {
                    low: Duration::from_micros( raw.low as u64 * raw.micro_sec_conv  ),
                    hi:  Duration::from_micros( raw.hi as u64 * raw.micro_sec_conv  ),
                    micro_sec_conv: raw.micro_sec_conv,
                }
            }
        }

        macro_rules! interval {
            ( $name:tt,
              $raw_low:expr,
              $raw_hi:expr,
              $raw_default:expr,
              $micro_sec_conv:expr
            ) => {
                #[cfg_attr(test,derive(Debug))]
                pub struct $name {
                    interval: u16,
                }

                impl $name {

                    const RAW_RANGE: ::hci::le::common::AdvIntRng<u16> = ::hci::le::common::AdvIntRng{
                        low: $raw_low,
                        hi: $raw_hi,
                        micro_sec_conv: $micro_sec_conv,
                    };

                    /// Create an advertising interval from a raw value
                    ///
                    /// A raw value is the value given to the Bluetooth Adapter for the advertising
                    /// interval. raw cannot be less than 0x0020 or more than 0x4000 per the 5.0
                    /// specification.
                    ///
                    /// # Error
                    /// The value is out of bounds.
                    pub fn try_from_raw( raw: u16 ) -> Result<Self, &'static str> {
                        if $name::RAW_RANGE.contains(&raw) {
                            Ok($name{
                                interval: raw,
                            })
                        }
                        else {
                            Err(concat!("Raw value out of range: ", $raw_low, "..=", $raw_hi))
                        }
                    }

                    /// Create an advertising interval from a Duration
                    ///
                    /// The duration value must not be less then 20ms or more then 10.24 seconds
                    ///
                    /// # Error
                    /// the value is out of bounds.
                    pub fn try_from_duration( duration: ::core::time::Duration ) -> Result<Self, &'static str>
                    {
                        let duration_range = ::hci::le::common::AdvIntRng::<::core::time::Duration>::from($name::RAW_RANGE);

                        if duration_range.contains(&duration) {
                            Ok( $name {
                                interval: (duration.as_secs() * (1000000 / $micro_sec_conv)) as u16 +
                                    (duration.subsec_micros() / $micro_sec_conv as u32) as u16,
                            })
                        }
                        else {
                            Err(concat!("Duration out of range: ",
                                stringify!( ($raw_low * $micro_sec_conv) ),
                                "us..=",
                                stringify!( ($raw_hi * $micro_sec_conv) ),
                                "us"))
                        }
                    }

                    pub fn get_raw_val(&self) -> u16 { self.interval }

                    pub fn get_duration(&self) -> ::core::time::Duration {
                        ::core::time::Duration::from_micros(
                            (self.interval as u64) * $micro_sec_conv
                        )
                    }
                }

                impl Default for $name {

                    /// Creates an Interval with the default value for the interval
                    ///
                    /// Both the minimum and maximum advertising interval have the same default
                    /// value.
                    fn default() -> Self {
                        $name{
                            interval: $raw_default,
                        }
                    }
                }
            };
        }
    }

    /// Manditory commands for a device that implements lE
    ///
    /// Some of these functions are not specific to Bluetooth LE, but they are here to be noted
    /// that they are associated with LE.
    ///
    /// Vol2 Part E 3.1 of the Bluetooth spec
    pub mod mandatory {

        macro_rules! add_remove_white_list_setup {
            ( $ocf: ident ) => {

                use bluez::{
                    $ocf,
                    OGF_LE_CTL
                };
                use hci::*;
                use hci::events::Events;
                use core::option::Option;
                pub use hci::le::common::AddressType;

                /// Command parameter data for both add and remove whitelist commands.
                ///
                /// Not using bluez becasue there are different parameter structs for the
                /// two commands even though they are the same in structure.
                #[repr(C, packed)]
                #[derive(Clone, Copy)]
                struct CommandPrameter {
                    address_type: u8,
                    address: [u8;6],
                }

                pub struct CommandBuilder {
                    addr_type: AddressType,
                    addr: Option<::BluetoothDeviceAddress>,
                }

                impl_status_return!( $ocf, OGF_LE_CTL);

                impl CommandBuilder {

                    /// Create a new builder of the command
                    pub fn new( at: AddressType ) -> CommandBuilder {
                        CommandBuilder {
                            addr_type: at,
                            addr: None,
                        }
                    }

                    /// Bluetooth address of the device
                    ///
                    /// This is only required to be set if the AddressType set in the call to new
                    /// is one of the following:
                    ///     - PublicDeviceAddress
                    ///     - RandomDeviceAddress
                    pub fn address( mut self, addr: ::BluetoothDeviceAddress ) -> Self {
                        self.addr = Some(addr);
                        self
                    }

                    fn address_ok(&self) -> bool {
                        match self.addr_type {
                            AddressType::PublicDeviceAddress |
                            AddressType::RandomDeviceAddress => {
                                self.addr.is_some()
                            },
                            #[cfg(bluetooth_5_0)] _ => true,
                        }
                    }

                    pub fn send(self, hci: &HostInterface ) -> Result<hci_return!(), &str> {

                        if ! self.address_ok() {
                            return Err("Address must be set for address type");
                        }

                        let parameter = CommandPrameter {
                            address_type: self.addr_type.to_value(),
                            address: self.addr.unwrap_or([0u8;6].into()),
                        };

                        Ok(hci.send_command(parameter, Events::CommandComplete, Duration::from_secs(1) ))
                    }
                }

                impl CommandParameters for CommandPrameter {
                    type Parameter = Self;
                    const OGF: u16 = OGF_LE_CTL as u16;
                    const OCF: u16 = $ocf as u16;
                    fn get_parameter(&self) -> Self::Parameter { *self }
                }
            };
        }
        pub mod add_device_to_white_list {

            add_remove_white_list_setup!(OCF_LE_ADD_DEVICE_TO_WHITE_LIST);

            #[cfg(test)]
            mod tests {

                use super::*;
                use bluez;
                use core::process::Command;
                use BluetoothDeviceAddress;
                use hci::test_util::block_for_command_result;

                #[test]
                fn add_device_to_white_list_test() {
                    let _u = ::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = BluetoothDeviceAddress::from([0x12,0x34,0x56,0x78,0x9A,0xBC]);

                    let test_address_1_str = bluez::bluetooth_address_to_string(test_address_1.clone());
                    let test_address_2_str = bluez::bluetooth_address_to_string(test_address_2.clone());

                    let adapter = HostInterface::default();

                    let result_1 = block_for_command_result(
                        CommandBuilder::new(AddressType::PublicDeviceAddress)
                        .address(test_address_1)
                        .send(&adapter)
                        .unwrap()  // Result from CommandBuilder::send
                        .unwrap() // Result from HostInterface::send_command
                    ).unwrap();

                    command_complete_test!(result_1, Return);

                    // remove the address from whitelist
                    // the anonomyous address is left
                    Command::new("hcitool")
                        .args(&["lewlrm", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    let result_2 = block_for_command_result(
                        CommandBuilder::new(AddressType::RandomDeviceAddress)
                        .address(test_address_2)
                        .send(&adapter)
                        .unwrap()  // Result from CommandBuilder::send
                        .unwrap() // Result from HostInterface::send_command
                    ).unwrap();

                    command_complete_test!(result_2, Return);

                    Command::new("hcitool")
                        .args(&["lewlrm", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    #[cfg(bluetooth_5_0)]
                    {
                        let result = block_for_command_result(
                            CommandBuilder::new(AddressType::DevicesSendingAnonymousAdvertisements)
                            .send(&adapter)
                            .unwrap()  // Result from CommandBuilder::send
                            .unwrap() // Result from HostInterface::send_command
                        ).unwrap();

                        assert_eq!(1, result.len() );

                        command_complete_test!(result[0], Return);
                    }
                }
            }
        }
        pub mod clear_white_list {

            use bluez::{
                OGF_LE_CTL,
                OCF_LE_CLEAR_WHITE_LIST,
            };
            use hci::*;

            #[derive(Clone, Copy)]
            struct Prameter;

            impl CommandParameters for Prameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_CLEAR_WHITE_LIST as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_status_return!( OCF_LE_CLEAR_WHITE_LIST, OGF_LE_CTL);

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Prameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use bluez;
                use hci::test_util::block_for_command_result;
                use std::process::Command;

                #[test]
                pub fn clear_white_list_test() {

                    let _u = ::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = ::BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = ::BluetoothDeviceAddress::from([0x12,0x34,0x45,0x56,0x78,0x8A]);

                    let test_address_1_str = bluez::bluetooth_address_to_string(test_address_1.clone());
                    let test_address_2_str = bluez::bluetooth_address_to_string(test_address_2.clone());

                    let host_interface = HostInterface::default();

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    let result = block_for_command_result(
                        send(&host_interface)
                        .unwrap()
                    ).unwrap();

                    command_complete_test!(result, Return);

                    let output_1 = Command::new("hcitool")
                        .args(&["lewlrm", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    let output_2 = Command::new("hcitool")
                        .args(&["lewlrm", &*test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    assert!( !output_1.status.success(), "hcitool should not have succeded");
                    assert!( !output_2.status.success(), "hcitool should not have succeded");
                }
            }
        }
        pub mod read_buffer_size {

            use bluez::{
                le_read_buffer_size_rp,
                OGF_LE_CTL,
                OCF_LE_READ_BUFFER_SIZE
            };
            use hci::*;

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_BUFFER_SIZE as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            /// This type consists of the ACL packet data length and total number of ACL data
            /// packets the Bluetooth device (controller portion) can store.
            ///
            /// If either member of BufferSize is None (they are either both None or both Some),
            /// then the Read Buffer Size (v5 | vol2, part E, sec 7.4.5) command should be used
            /// instead.
            #[derive(Debug)]
            pub struct BufferSize {
                /// The maximum size of each packet
                pub packet_len: Option<u16>,
                /// The maximum number of packets that the controller can hold
                pub packet_cnt: Option<u8>,
            }

            impl BufferSize {
                fn try_from(packed: le_read_buffer_size_rp) -> Result<Self, error::Error >{
                    let err_val = error::Error::from(packed.status);

                    match err_val {
                        error::Error::NoError => {
                            let len = if packed.pkt_len != 0 { Some(packed.pkt_len) } else { None };
                            let cnt = if packed.max_pkt != 0 { Some(packed.max_pkt) } else { None };

                            Ok(BufferSize {
                                packet_len: len,
                                packet_cnt: cnt,
                            })
                        },
                        _ => Err(err_val),
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_BUFFER_SIZE,
                OGF_LE_CTL,
                le_read_buffer_size_rp,
                BufferSize,
                error::Error);

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_buffer_size_test() {

                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    ).unwrap();

                    command_complete_test!(result, BufferSize);
                }
            }
        }
        pub mod read_local_supported_features {

            use bluez::{
                le_read_local_supported_features_rp,
                OGF_LE_CTL,
                OCF_LE_READ_LOCAL_SUPPORTED_FEATURES
            };
            use hci::common::EnabledLEFeaturesItr;
            use hci::*;

            impl EnabledLEFeaturesItr {
                fn try_from( packed: le_read_local_supported_features_rp ) -> Result<Self,error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(EnabledLEFeaturesItr::from(packed.features))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_LOCAL_SUPPORTED_FEATURES,
                OGF_LE_CTL,
                le_read_local_supported_features_rp,
                EnabledLEFeaturesItr,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_LOCAL_SUPPORTED_FEATURES as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_local_supported_features_test() {

                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    ).unwrap();

                    command_complete_test!(result, EnabledLEFeaturesItr);
                }
            }
        }
        pub mod read_supported_states {

            use bluez::{
                le_read_supported_states_rp,
                OGF_LE_CTL,
                OCF_LE_READ_SUPPORTED_STATES
            };
            use hci::*;
            use alloc::collections::BTreeSet;
            use alloc::vec::Vec;
            use core::mem::size_of_val;


            /// All possible states/roles a controller can be in
            #[derive(PartialEq,Eq,PartialOrd,Ord,Debug)]
            pub enum StatesAndRoles {
                ScannableAdvertisingState,
                ConnectableAdvertisingState,
                NonConnectableAdvertisingState,
                HighDutyCyleDirectedAdvertisingState,
                LowDutyCycleDirectedAdvertisingState,
                ActiveScanningState,
                PassiveScanningState,
                InitiatingState,
                ConnectionStateMasterRole,
                ConnectionStateSlaveRole
            }

            impl StatesAndRoles {

                /// Returns the total number of states and roles
                fn get_count() -> usize { 10 }

                /// Returns the total possible bit options
                ///
                /// See Bluetooth v5 vol 2 part E 7.8.27
                fn get_bit_count() -> usize { 41 }

                /// This function doesn't return all available states and roles of a device
                /// (since devices can set multiple of these bits indicating the available
                /// roles) so it doesn't return the special type name.
                fn get_states_for_bit_val( bit_val: usize) -> Vec<Self> {
                    use self::StatesAndRoles::*;

                    match bit_val {
                        0  => vec![ NonConnectableAdvertisingState],
                        1  => vec![ ScannableAdvertisingState],
                        2  => vec![ ConnectableAdvertisingState],
                        3  => vec![ HighDutyCyleDirectedAdvertisingState],
                        4  => vec![ PassiveScanningState],
                        5  => vec![ ActiveScanningState],
                        6  => vec![ InitiatingState],
                        7  => vec![ ConnectionStateSlaveRole],
                        8  => vec![ NonConnectableAdvertisingState,
                                    PassiveScanningState],
                        9  => vec![ ScannableAdvertisingState,
                                    PassiveScanningState],
                        10 => vec![ ConnectableAdvertisingState,
                                    PassiveScanningState],
                        11 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    PassiveScanningState],
                        12 => vec![ NonConnectableAdvertisingState,
                                    ActiveScanningState],
                        13 => vec![ ScannableAdvertisingState,
                                    ActiveScanningState],
                        14 => vec![ ConnectableAdvertisingState,
                                    ActiveScanningState],
                        15 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ActiveScanningState],
                        16 => vec![ NonConnectableAdvertisingState,
                                    InitiatingState],
                        17 => vec![ ScannableAdvertisingState,
                                    InitiatingState],
                        18 => vec![ NonConnectableAdvertisingState,
                                    ConnectionStateMasterRole],
                        19 => vec![ ScannableAdvertisingState,
                                    ConnectionStateMasterRole],
                        20 => vec![ NonConnectableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        21 => vec![ ScannableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        22 => vec![ PassiveScanningState,
                                    InitiatingState],
                        23 => vec![ ActiveScanningState,
                                    InitiatingState],
                        24 => vec![ PassiveScanningState,
                                    ConnectionStateMasterRole],
                        25 => vec![ ActiveScanningState,
                                    ConnectionStateMasterRole],
                        26 => vec![ PassiveScanningState,
                                    ConnectionStateSlaveRole],
                        27 => vec![ ActiveScanningState,
                                    ConnectionStateSlaveRole],
                        28 => vec![ InitiatingState,
                                    ConnectionStateMasterRole],
                        29 => vec![ LowDutyCycleDirectedAdvertisingState ],
                        30 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    PassiveScanningState],
                        31 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ActiveScanningState],
                        32 => vec![ ConnectableAdvertisingState,
                                    InitiatingState],
                        33 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    InitiatingState],
                        34 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    InitiatingState],
                        35 => vec![ ConnectableAdvertisingState,
                                    ConnectionStateMasterRole],
                        36 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ConnectionStateMasterRole],
                        37 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ConnectionStateMasterRole],
                        38 => vec![ ConnectableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        39 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ConnectionStateSlaveRole],
                        40 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ConnectionStateSlaveRole],
                        41 => vec![ InitiatingState,
                                    ConnectionStateSlaveRole],
                        _  => vec![],
                    }
                }

                fn collect_to_vec( bts: BTreeSet<StatesAndRoles> ) -> Vec<Self> {
                    let mut retval = Vec::<Self>::with_capacity(
                        StatesAndRoles::get_count()
                    );

                    for state_or_role in bts {
                        retval.push(state_or_role)
                    }

                    retval
                }

                /// This function will return all the supported states
                fn get_supported_states( rss: &le_read_supported_states_rp) -> Vec<Self> {

                    let mut set = BTreeSet::new();

                    let count = StatesAndRoles::get_bit_count();

                    let temp = rss.states;

                    for bit in 0..(size_of_val(&temp) * 8) {
                        if bit < count {
                            if 0 != rss.states & ( 1 << bit ) {
                                for state_or_role in StatesAndRoles::get_states_for_bit_val( bit ) {
                                    set.insert(state_or_role);
                                }
                            }
                        }
                        else {
                            return StatesAndRoles::collect_to_vec(set);
                        }
                    }
                    StatesAndRoles::collect_to_vec(set)
                }

                fn try_from(packed: le_read_supported_states_rp) -> Result<Vec<Self>, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(StatesAndRoles::get_supported_states(&packed))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_SUPPORTED_STATES,
                OGF_LE_CTL,
                le_read_supported_states_rp,
                StatesAndRoles,
                Vec<StatesAndRoles>,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_SUPPORTED_STATES as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_supported_states_test() {

                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    ).unwrap();

                    command_complete_test!(result, StatesAndRoles);
                }
            }
        }
        pub mod read_white_list_size {

            use bluez::{
                le_read_white_list_size_rp,
                OGF_LE_CTL,
                OCF_LE_READ_WHITE_LIST_SIZE,
            };
            use hci::*;

            pub struct Return;

            impl Return {
                fn try_from( packed: le_read_white_list_size_rp) -> Result<usize, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.size as usize)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command! (
                OCF_LE_READ_WHITE_LIST_SIZE,
                OGF_LE_CTL,
                le_read_white_list_size_rp,
                Return,
                usize,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_WHITE_LIST_SIZE as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::process::Command;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_white_list_size_test() {

                    let output = Command::new("hcitool")
                        .arg("lewlsz")
                        .output()
                        .expect("failed to execute process");

                    let hcitool_cnt = String::from_utf8_lossy(&output.stdout)
                            .trim_left_matches("White list size: ")
                            .trim_right()
                            .parse::<usize>()
                            .expect("Couldn't convert string to number");

                    let hci_result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    ).unwrap();

                    command_complete_test!(hci_result, Return, hcitool_cnt);
                }
            }
        }
        pub mod remove_device_from_white_list {

            add_remove_white_list_setup!(OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST);

            #[cfg(test)]
            mod tests {

                use super::*;
                use bluez;
                use hci::test_util::block_for_command_result;
                use std::process::Command;

                #[test]
                fn remove_device_from_white_list_test() {

                    let _u = ::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = ::BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = ::BluetoothDeviceAddress::from([0x12,0x34,0x45,0x56,0x78,0x8A]);
                    let test_address_3 = ::BluetoothDeviceAddress::from([0xff,0xee,0xdd,0xcc,0xbb,0xaa]);

                    let test_address_1_str = bluez::bluetooth_address_to_string(test_address_1.clone());
                    let test_address_2_str = bluez::bluetooth_address_to_string(test_address_2.clone());

                    let hi = HostInterface::default();

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    Command::new("hcitool")
                        .args(&["lewladd", "--random", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    let result_l = block_for_command_result(
                        CommandBuilder::new(AddressType::PublicDeviceAddress)
                            .address(test_address_1)
                            .send(&hi)
                            .unwrap()
                            .unwrap()
                    )
                    .unwrap();

                    let result_2 = block_for_command_result(
                        CommandBuilder::new(AddressType::PublicDeviceAddress)
                            .address(test_address_2)
                            .send(&hi)
                            .unwrap()
                            .unwrap()
                    )
                    .unwrap();

                    let result_3 = block_for_command_result(
                        CommandBuilder::new(AddressType::PublicDeviceAddress)
                            .address(test_address_3)
                            .send(&hi)
                            .unwrap()
                            .unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result_l, Return);
                    command_complete_test!(result_2, Return);
                    command_complete_test!(result_3, Return);
                }
            }
        }
        pub mod set_event_mask {

            use bluez::{
                le_set_event_mask_cp,
                OGF_LE_CTL,
                OCF_LE_SET_EVENT_MASK,
            };
            use hci::*;
            use alloc::vec::Vec;

            #[cfg_attr(test, derive(Debug))]
            pub enum Events {
                LEConnectionComplete,
                LEAdvertisingReport,
                LEConnectionUpdateComplete,
                LEReadRemoteFeaturesComplete,
                LELongTermKeyRequest,
                LERemoteConnectionParameterRequest,
                LEDataLengthChange,
                LEReadLocalP256PublicKeyComplete,
                LEGenerateDHKeyComplete,
                LEEnhancedConnectionComplete,
                LEDirectedAdvertisingReport,
                LEPHYUpdateComplete,
                LEExtendedAdvertisingReport,
                LEPeriodicAdvertisingSyncEstablished,
                LEPeriodicAdvertisingReport,
                LEPeriodicAdvertisingSyncLost,
                LEExtendedScanTimeout,
                LEExtendedAdvertisingSetTerminated,
                LEScanRequestReceived,
                LEChannelSelectionAlgorithm,
            }

            impl Events {

                fn bit_offset(&self) -> usize{
                    match *self {
                        Events::LEConnectionComplete => 0,
                        Events::LEAdvertisingReport => 1,
                        Events::LEConnectionUpdateComplete => 2,
                        Events::LEReadRemoteFeaturesComplete => 3,
                        Events::LELongTermKeyRequest => 4,
                        Events::LERemoteConnectionParameterRequest => 5,
                        Events::LEDataLengthChange => 6,
                        Events::LEReadLocalP256PublicKeyComplete => 7,
                        Events::LEGenerateDHKeyComplete => 8,
                        Events::LEEnhancedConnectionComplete => 9,
                        Events::LEDirectedAdvertisingReport => 10,
                        Events::LEPHYUpdateComplete => 11,
                        Events::LEExtendedAdvertisingReport => 12,
                        Events::LEPeriodicAdvertisingSyncEstablished => 13,
                        Events::LEPeriodicAdvertisingReport => 14,
                        Events::LEPeriodicAdvertisingSyncLost => 15,
                        Events::LEExtendedScanTimeout => 16,
                        Events::LEExtendedAdvertisingSetTerminated => 17,
                        Events::LEScanRequestReceived => 18,
                        Events::LEChannelSelectionAlgorithm => 19,
                    }
                }

                fn build_mask( events: Vec<Self>) -> [u8;8] {
                    let mut mask = <[u8;8]>::default();

                    for event in events {
                        let bit = event.bit_offset();
                        let byte = bit/8;

                        mask[byte] |= 1 << bit;
                    }

                    mask
                }
            }

            impl_status_return!( OCF_LE_SET_EVENT_MASK, OGF_LE_CTL);

            impl CommandParameters for le_set_event_mask_cp {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_EVENT_MASK as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// Set the enabled events on a device
            ///
            /// ```rust
            /// # use bo_tie_linux::hci::le::mandatory::set_event_mask::*;
            /// # let host_interface = bo_tie_linux::hci::HostInterface::default();
            ///
            /// let events = vec!(Events::LEConnectionComplete,Events::LEAdvertisingReport);
            ///
            /// // This will enable the LE Connection Complete Event and LE Advertising Report Event
            /// send(&host_interface, events);
            /// ```
            pub fn send( hi: &HostInterface, enabled_events: Vec<Events>) -> hci_return!() {

                let command_pram = le_set_event_mask_cp {
                    mask: Events::build_mask(enabled_events),
                };

                hi.send_command(command_pram, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn set_event_mask_test() {

                    let hi = HostInterface::default();

                    let enabled_events = vec! [
                        Events::LEConnectionComplete,
                        Events::LEAdvertisingReport,
                        Events::LEConnectionUpdateComplete,
                        Events::LEReadRemoteFeaturesComplete,
                    ];

                    let result = block_for_command_result(
                        send( &hi, enabled_events ).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
        pub mod test_end {
            use bluez::{
                le_test_end_rp,
                OCF_LE_TEST_END,
                OGF_LE_CTL,
            };
            use hci::*;

            pub struct Return;

            impl Return {
                fn try_from(packed: le_test_end_rp) -> Result<usize, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.num_pkts as usize)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_LE_TEST_END,
                OGF_LE_CTL,
                le_test_end_rp,
                Return,
                usize,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_TEST_END as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// This will return a future with its type 'Output' being the number of packets
            /// received during what ever test was done
            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                #[should_panic]
                fn test_end_test() {

                    let result = block_for_command_result(
                        send( &HostInterface::default() ).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
        /// This is part of the Informational Parameters opcode group
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_bd_addr {

            use BluetoothDeviceAddress;
            use bluez::{
                read_bd_addr_rp,
                OCF_READ_BD_ADDR,
                OGF_INFO_PARAM,
            };
            use hci::*;

            struct Return;

            impl Return {
                fn try_from(packed: read_bd_addr_rp) -> Result<BluetoothDeviceAddress, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.bdaddr.b)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_READ_BD_ADDR,
                OGF_INFO_PARAM,
                read_bd_addr_rp,
                Return,
                BluetoothDeviceAddress,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_INFO_PARAM as u16;
                const OCF: u16 = OCF_READ_BD_ADDR as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// Returns the bluetooth device address for the device
            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::process::Command;
                use std::iter::Iterator;
                use hci::test_util::block_for_command_result;

                trait TryCollect<A> {
                    fn try_collect(self) -> Result<A,&'static str>;
                }

                impl<T> TryCollect<[u8;6]> for T where T: Iterator<Item=u8> {

                    fn try_collect(self) -> Result<[u8;6],&'static str> {
                        let mut arr = [0u8;6];

                        let mut index = 0;
                        for val in self {
                            if index < 6 {
                                arr[index] = val;
                                index += 1
                            }
                            else {
                                return Err("Device address is too large");
                            }
                        }

                        if index < 6 {
                            Err("Device address is too small")
                        }
                        else {
                            Ok(arr)
                        }
                    }
                }

                #[test]
                fn ip_read_bd_addr_test() {

                    let output = Command::new("hcitool")
                        .arg("dev")
                        .output()
                        .expect("failed to execute process");

                    let mut hcitool_bdaddr: BluetoothDeviceAddress =
                        String::from_utf8_lossy(&output.stdout)
                            .trim_left_matches(|c: char| c != '0')
                            .trim_left_matches("0")
                            .trim()
                            .split(":")
                            .map(|s| u8::from_str_radix(s,16).unwrap() )
                            .try_collect()
                            .unwrap();

                    hcitool_bdaddr.reverse();

                    let result = block_for_command_result(
                         send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return, hcitool_bdaddr);
                }
            }
        }
        /// This is part of the Informational Parameters opcode group
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_supported_features {

            use bluez::{
                read_local_features_rp,
                OCF_READ_LOCAL_FEATURES,
                OGF_INFO_PARAM,
            };
            use hci::*;
            use hci::common::EnabledFeaturesIter;

            impl EnabledFeaturesIter {
                fn try_from(packed: read_local_features_rp) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(EnabledFeaturesIter::from(packed.features))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command! (
                OCF_READ_LOCAL_FEATURES,
                OGF_INFO_PARAM,
                read_local_features_rp,
                EnabledFeaturesIter,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_INFO_PARAM as u16;
                const OCF: u16 = OCF_READ_LOCAL_FEATURES as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn ip_read_local_supported_features() {

                    let result = block_for_command_result(
                         send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, EnabledFeaturesIter);
                }
            }
        }
        // This is part of the Information Parameters opcode group
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_version_information {

            use bluez::{
                read_local_version_rp,
                OCF_READ_LOCAL_FEATURES,
                OGF_INFO_PARAM,
            };
            use hci::*;

            #[derive(Debug)]
            pub struct VersionInformation {
                pub hci_version: u8,
                pub hci_revision: u16,
                pub lmp_pal_version: u8,
                pub manufacturer_name: u16,
                pub lmp_pal_subversion: u16,
            }

            impl VersionInformation {
                fn try_from(packed: read_local_version_rp) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok( Self {
                            hci_version: packed.hci_ver,
                            hci_revision: packed.hci_rev,
                            lmp_pal_version: packed.lmp_ver,
                            manufacturer_name: packed.manufacturer,
                            lmp_pal_subversion: packed.lmp_subver,
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_READ_LOCAL_FEATURES,
                OGF_INFO_PARAM,
                read_local_version_rp,
                VersionInformation,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_INFO_PARAM as u16;
                const OCF: u16 = OCF_READ_LOCAL_FEATURES as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn ip_read_local_version_information_test() {
                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, VersionInformation);
                }
            }
        }
        // This is part of the Host Controller and Baseband opcode group
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod reset {

            use bluez::{
                OCF_RESET,
                OGF_HOST_CTL,
            };
            use hci::*;

            impl_status_return!(OCF_RESET, OGF_HOST_CTL);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_HOST_CTL as u16;
                const OCF: u16 = OCF_RESET as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn reset_test() {

                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return );
                }
            }
        }
        // This is part of the Informational Parameters opcode group
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_supported_commands {
            use bluez::{
                read_local_commands_rp,
                OCF_READ_LOCAL_COMMANDS,
                OGF_INFO_PARAM,
            };
            use hci::*;
            use core::option::Option;
            use alloc::vec::Vec;

            #[cfg_attr(test,derive(Debug))]
            #[derive(PartialEq)]
            pub enum SupportedCommands {
                Inquiry,
                InquiryCancel,
                PeriodicInquiryMode,
                ExitPeriodicInquiryMode,
                CreateConnection,
                Disconnect,
                /// Depreciated
                AddSCOConnection,
                CreateConnectionCancel,
                AcceptConnectionRequest,
                RejectConnectionRequest,
                LinkKeyRequestReply,
                LinkKeyRequestNegativeReply,
                PINCodeRequestReply,
                PINCodeRequestNegativeReply,
                ChangeConnectionPacketType,
                AuthenticationRequested,
                SetConnectionEncryption,
                ChangeConnectionLinkKey,
                MasterLinkKey,
                RemoteNameRequest,
                RemoteNameRequestCancel,
                ReadRemoteSupportedFeatures,
                ReadRemoteExtendedFeatures,
                ReadRemoteVersionInformation,
                ReadClockOffset,
                ReadLMPHandle,
                HoldMode,
                SniffMode,
                ExitSniffMode,
                QosSetup,
                RoleDiscovery,
                SwitchRole,
                ReadLinkPolicySettings,
                WriteLinkPolicySettings,
                ReadDefaultLinkPolicySettings,
                WriteDefaultLinkPolicySettings,
                FlowSpecification,
                SetEventMask,
                Reset,
                SetEVentFilter,
                Flush,
                ReadPINType,
                WritePINType,
                CreateNewUnitKey,
                ReadStoredLinkKey,
                WriteStoredLinkKey,
                DeleteStoredLinkKey,
                WriteLocalName,
                ReadLocalName,
                ReadConnectionAcceptedTimeout,
                WriteConnectionAcceptedTimeout,
                ReadPageTimeout,
                WritePageTimeout,
                ReadScanEnable,
                WriteScanEnable,
                ReadPageScanActivity,
                WritePageScanActivity,
                ReadInquiryScanActivity,
                WriteInquiryScanActivity,
                ReadAuthenticationEnable,
                WriteAuthenticationEnable,
                ///Depreciated
                ReadEncryptionMode,
                ///Depreciated
                WriteEncryptionMode,
                ReadClassOfDevice,
                WriteClassOfDevice,
                REadVoiceSetting,
                WriteVoiceSetting,
                ReadAutomaticFlushTimeout,
                WriteAutomaticFlushTimeout,
                ReadNumBroadcastRetransmission,
                WriteNumBroadcastRetransmissions,
                ReadHoldModeActivity,
                WriteHoldModeActiviy,
                ReadTransmitPowerLevel,
                ReadSynchronousFlowControlEnable,
                WriteSynchronousFlowControlEnable,
                SetConrollerToHostFlowControl,
                HostBufferSize,
                HostNumberOfCompletedPackets,
                ReadLinkSupervisionTimeout,
                WriteLinkSupervisionTimeout,
                ReadNumberOfSupportedIAC,
                ReadCurrentIACLAP,
                WriteCurrentIACLAP,
                /// Depreciated
                ReadPageScanModePeriod,
                /// Depreciated
                WritePageScanModePeriod,
                /// Depreciated
                ReadPageScanMode,
                /// Depreciated
                WritePageSanMode,
                SetAFHHostChannel,
                ReadInquiryScanType,
                WriteInquirySCanType,
                ReadInquiryMode,
                WriteInquiryMode,
                ReadPageScanType,
                WritePageScanType,
                ReadAFHChannelAssessmentMode,
                WriteAFHChannelAssessmentMode,
                ReadLocalVersionInformation,
                ReadLocalSupportedFeatures,
                ReadLocalExtendedFeatures,
                ReadBufferSize,
                /// Depreciated
                ReadCountryCode,
                ReadBDADDR,
                ReadFAiledContactCounter,
                ResetFailedContactCounter,
                ReadLinkQuality,
                ReadRSSI,
                ReadAFHChannelMap,
                ReadClock,
                ReadLoopbackMode,
                WriteLoopbackMode,
                EnableDeviceUnderTestMode,
                SetupSynchronousConnectionRequest,
                AcceptSynchronousConnectionRequest,
                RejectSynchronousConnectionRequest,
                ReadExtendedInquiryResponse,
                WriteExtendedInquiryResponse,
                RefreshEncryptionKey,
                SniffSubrating,
                ReadSimplePairingMode,
                WriteSimplePairingMode,
                ReadLocalOOBData,
                ReadInquiryResponseTransmitPowerLevel,
                WriteInquiryTransmitPowerLevel,
                ReadDefaultErroneousDataReporting,
                WriteDefaultErroneousDataReporting,
                IOCapabilityRequestReply,
                UserConfirmationRequestReply,
                UserConfirmationRequestNegativeReply,
                UserPasskeyRequestReply,
                UserPasskeyRequestNegativeReply,
                RemoteOOBDataRequestReply,
                WriteSimplePairingDebugMode,
                EnhancedFlush,
                RemoteOOBDataRequestNagativeReply,
                SendKeypressNotification,
                IOCapabilityRequestNegativeReply,
                ReadEncryptionKeySize,
                CreatePhysicalLink,
                AcceptPhysicalLink,
                DisconnectPhysicalLink,
                CreateLogicalLink,
                AcceptLogicalLink,
                DisconnectLogicalLink,
                LogicalLinkCancel,
                FlowSpecModify,
                ReadLogicalLinkAcceptTimeout,
                WriteLogicalLinkAcceptTimeout,
                SetEventMaskPage2,
                ReadLocationData,
                WRiteLocationData,
                ReadLocalAMPInfo,
                ReadLocalAMPASSOC,
                WriteRemoteAMPASSOC,
                READFlowControlMode,
                WriteFlowControlMode,
                ReadDataBlockSize,
                EnableAMPReceiverReports,
                AMPTestEnd,
                AmPTest,
                ReadEnhancedTransmitPowerLevel,
                ReadBestEffortFlushTimeout,
                WriteBestEffortFlushTimeout,
                ShortRangeMode,
                ReadLEHostSupport,
                WriteLEHostSupport,
                LESetEventMask,
                LEReadBufferSize,
                LEReadLocalSupportedFeatures,
                LESetRandomAddress,
                LESetAdvertisingParameters,
                LEReadAdvertisingChannelTXPower,
                LESetAdvertisingData,
                LESetScanResponseData,
                LESetAdvertisingEnable,
                LESetScanParameters,
                LESetScanEnable,
                LECreateConnection,
                LECreateConnectionCancel,
                LEReadWhiteListSize,
                LEClearWhiteList,
                LEAddDeviceToWhiteList,
                LERemoveDeviceFromWhiteList,
                LEConnectionUpdate,
                LESetHostChannelClassification,
                LEReadChannelMap,
                LEReadRemoteFeatures,
                LEEncrypt,
                LERand,
                LEStartEncryption,
                LELongTermKeyRequestReply,
                LELongTermKeyRequestNegativeReply,
                LEReadSupportedStates,
                LEReceiverTest,
                LETransmitterTest,
                LETestEnd,
                EnhancedSetupSynchronousConnection,
                EnhancedAcceptSynchronousConnection,
                ReadLocalSupportedCondecs,
                SetMWSChannelParameters,
                SetExternalFrameConfiguration,
                SetMWSSignaling,
                SetMWSTransportLayer,
                SetMWSScanFrequencyTable,
                GetMWSTransportLayerConfiguration,
                SetMWSPATTERNConfiguration,
                SetTriggeredClockCapture,
                TruncatedPage,
                TruncatedPageCancel,
                SetConnectionlessSlaveBroadcast,
                SetConnectionlessSlaveBroadcastReceive,
                StartSynchronizationTrain,
                ReceiveSynchronizationTrain,
                SetReservedLTADDR,
                DeleteReservedLTADDR,
                SetConnectionlessSlaveBroadcastData,
                ReadSynchronizationTrainParameters,
                WriteSynchronizationTrainParameters,
                RemoteOOBExtendedDataRequestReply,
                ReadSecureConnectionsHostSupport,
                WriteSecureConnectionsHostSupport,
                ReadAuthenticatedPayloadTimeout,
                WriteAuthenticatedPayloadTimeout,
                ReadLocalOOBExtendedData,
                WriteSecureConnectionsTestMode,
                ReadExtendedPageTimeout,
                WriteExtendedPageTimeout,
                ReadExtendedInquiryLength,
                WriteExtendedInquiryLengh,
                LERemoteConnectionParameterRequestReply,
                LERemoteConnectionParameterREquestNegativeReply,
                LESetDataLength,
                LEReadSuggestedDefaultDataLength,
                LEWriteSuggestedDefaultDataLength,
                LEReadLocalP256PublicKey,
                LEGenerateDHKey,
                LEAddDeviceToResolvingList,
                LERemoveDeviceFromResolvingList,
                LEClearResolvingList,
                LEReadResolvingListSize,
                LEReadPeerResolvableAddress,
                LEReadLocalResolvableAddress,
                LESetAddressResolutionEnable,
                LESetResolvablePrivateAddressTimeout,
                LEReadMaximumDataLength,
                LEReadPHYCommand,
                LESetDefaultPHYCommand,
                LESetPHYCommand,
                LEEnhancedReceiverTestCommand,
                LEEnhancedTransmitterTestCommand,
                LESetAdvertisingSetRandomAddressCommand,
                LESetExtendedAdvertisingParametersCommand,
                LESetExtendedAdvertisingDataCommand,
                LESetExtendedScanResponseDataCommand,
                LESetExtendedAdvertisingEnableCommand,
                LEReadMaximumAdvertisingDataLengthCommand,
                LEReadNumberOfSupportedAdvertisingSetCommand,
                LERemoveAdvertisingSetCommand,
                LEClearAdvertisingSetsCommand,
                LESetPeriodicAdvertisingParametersCommand,
                LESetPeriodicAdvertisingDataCommand,
                LESetPeriodicAdvertisingEnableCommand,
                LESetExtendedScanParametersCommand,
                LESetExtendedScanEnableCommand,
                LEExtendedCreateConnectionCommand,
                LEPeriodicAdvertisingCreateSyncCommand,
                LEPeriodicAdvertisingCreateSyncCancelCommand,
                LEPeriodicAdvertisingTerminateSyncCommand,
                LEAddDeviceToPeriodicAdvertiserListCommand,
                LERemoveDeviceFromPeriodicAdvertiserListCommand,
                LEClearPeriodicAdvertiserListCommand,
                LEReadPeriodicAdvertiserListSizeCommand,
                LEReadTransmitPowerCommand,
                LEReadRFPathCompensationCommand,
                LEWriteRFPathCompensationCommand,
                LESetPrivacyMode,
            }

            impl SupportedCommands {

                fn from_bit_pos( pos: (usize, usize) ) -> Option<SupportedCommands> {
                    use self::SupportedCommands::*;

                    match pos {
                        (0,0)  => Some(Inquiry),
                        (0,1)  => Some(InquiryCancel),
                        (0,2)  => Some(PeriodicInquiryMode),
                        (0,3)  => Some(ExitPeriodicInquiryMode),
                        (0,4)  => Some(CreateConnection),
                        (0,5)  => Some(Disconnect),
                        (0,6)  => Some(AddSCOConnection),
                        (0,7)  => Some(CreateConnectionCancel),
                        (1,0)  => Some(AcceptConnectionRequest),
                        (1,1)  => Some(RejectConnectionRequest),
                        (1,2)  => Some(LinkKeyRequestReply),
                        (1,3)  => Some(LinkKeyRequestNegativeReply),
                        (1,4)  => Some(PINCodeRequestReply),
                        (1,5)  => Some(PINCodeRequestNegativeReply),
                        (1,6)  => Some(ChangeConnectionPacketType),
                        (1,7)  => Some(AuthenticationRequested),
                        (2,0)  => Some(SetConnectionEncryption),
                        (2,1)  => Some(ChangeConnectionLinkKey),
                        (2,2)  => Some(MasterLinkKey),
                        (2,3)  => Some(RemoteNameRequest),
                        (2,4)  => Some(RemoteNameRequestCancel),
                        (2,5)  => Some(ReadRemoteSupportedFeatures),
                        (2,6)  => Some(ReadRemoteExtendedFeatures),
                        (2,7)  => Some(ReadRemoteVersionInformation),
                        (3,0)  => Some(ReadClockOffset),
                        (3,1)  => Some(ReadLMPHandle),
                        (4,1)  => Some(HoldMode),
                        (4,2)  => Some(SniffMode),
                        (4,3)  => Some(ExitSniffMode),
                        (4,6)  => Some(QosSetup),
                        (4,7)  => Some(RoleDiscovery),
                        (5,0)  => Some(SwitchRole),
                        (5,1)  => Some(ReadLinkPolicySettings),
                        (5,2)  => Some(WriteLinkPolicySettings),
                        (5,3)  => Some(ReadDefaultLinkPolicySettings),
                        (5,4)  => Some(WriteDefaultLinkPolicySettings),
                        (5,5)  => Some(FlowSpecification),
                        (5,6)  => Some(SetEventMask),
                        (5,7)  => Some(Reset),
                        (6,0)  => Some(SetEVentFilter),
                        (6,1)  => Some(Flush),
                        (6,2)  => Some(ReadPINType),
                        (6,3)  => Some(WritePINType),
                        (6,4)  => Some(CreateNewUnitKey),
                        (6,5)  => Some(ReadStoredLinkKey),
                        (6,6)  => Some(WriteStoredLinkKey),
                        (6,7)  => Some(DeleteStoredLinkKey),
                        (7,0)  => Some(WriteLocalName),
                        (7,1)  => Some(ReadLocalName),
                        (7,2)  => Some(ReadConnectionAcceptedTimeout),
                        (7,3)  => Some(WriteConnectionAcceptedTimeout),
                        (7,4)  => Some(ReadPageTimeout),
                        (7,5)  => Some(WritePageTimeout),
                        (7,6)  => Some(ReadScanEnable),
                        (7,7)  => Some(WriteScanEnable),
                        (8,0)  => Some(ReadPageScanActivity),
                        (8,1)  => Some(WritePageScanActivity),
                        (8,2)  => Some(ReadInquiryScanActivity),
                        (8,3)  => Some(WriteInquiryScanActivity),
                        (8,4)  => Some(ReadAuthenticationEnable),
                        (8,5)  => Some(WriteAuthenticationEnable),
                        (8,6)  => Some(ReadEncryptionMode),
                        (8,7)  => Some(WriteEncryptionMode),
                        (9,0)  => Some(ReadClassOfDevice),
                        (9,1)  => Some(WriteClassOfDevice),
                        (9,2)  => Some(REadVoiceSetting),
                        (9,3)  => Some(WriteVoiceSetting),
                        (9,4)  => Some(ReadAutomaticFlushTimeout),
                        (9,5)  => Some(WriteAutomaticFlushTimeout),
                        (9,6)  => Some(ReadNumBroadcastRetransmission),
                        (9,7)  => Some(WriteNumBroadcastRetransmissions),
                        (10,0) => Some(ReadHoldModeActivity),
                        (10,1) => Some(WriteHoldModeActiviy),
                        (10,2) => Some(ReadTransmitPowerLevel),
                        (10,3) => Some(ReadSynchronousFlowControlEnable),
                        (10,4) => Some(WriteSynchronousFlowControlEnable),
                        (10,5) => Some(SetConrollerToHostFlowControl),
                        (10,6) => Some(HostBufferSize),
                        (10,7) => Some(HostNumberOfCompletedPackets),
                        (11,0) => Some(ReadLinkSupervisionTimeout),
                        (11,1) => Some(WriteLinkSupervisionTimeout),
                        (11,2) => Some(ReadNumberOfSupportedIAC),
                        (11,3) => Some(ReadCurrentIACLAP),
                        (11,4) => Some(WriteCurrentIACLAP),
                        (11,5) => Some(ReadPageScanModePeriod),
                        (11,6) => Some(WritePageScanModePeriod),
                        (11,7) => Some(ReadPageScanMode),
                        (12,0) => Some(WritePageSanMode),
                        (12,1) => Some(SetAFHHostChannel),
                        (12,4) => Some(ReadInquiryScanType),
                        (12,5) => Some(WriteInquirySCanType),
                        (12,6) => Some(ReadInquiryMode),
                        (12,7) => Some(WriteInquiryMode),
                        (13,0) => Some(ReadPageScanType),
                        (13,1) => Some(WritePageScanType),
                        (13,2) => Some(ReadAFHChannelAssessmentMode),
                        (13,3) => Some(WriteAFHChannelAssessmentMode),
                        (14,3) => Some(ReadLocalVersionInformation),
                        (14,5) => Some(ReadLocalSupportedFeatures),
                        (14,6) => Some(ReadLocalExtendedFeatures),
                        (14,7) => Some(ReadBufferSize),
                        (15,0) => Some(ReadCountryCode),
                        (15,1) => Some(ReadBDADDR),
                        (15,2) => Some(ReadFAiledContactCounter),
                        (15,3) => Some(ResetFailedContactCounter),
                        (15,4) => Some(ReadLinkQuality),
                        (15,5) => Some(ReadRSSI),
                        (15,6) => Some(ReadAFHChannelMap),
                        (15,7) => Some(ReadClock),
                        (16,0) => Some(ReadLoopbackMode),
                        (16,1) => Some(WriteLoopbackMode),
                        (16,2) => Some(EnableDeviceUnderTestMode),
                        (16,3) => Some(SetupSynchronousConnectionRequest),
                        (16,4) => Some(AcceptSynchronousConnectionRequest),
                        (16,5) => Some(RejectSynchronousConnectionRequest),
                        (17,0) => Some(ReadExtendedInquiryResponse),
                        (17,1) => Some(WriteExtendedInquiryResponse),
                        (17,2) => Some(RefreshEncryptionKey),
                        (17,4) => Some(SniffSubrating),
                        (17,5) => Some(ReadSimplePairingMode),
                        (17,6) => Some(WriteSimplePairingMode),
                        (17,7) => Some(ReadLocalOOBData),
                        (18,0) => Some(ReadInquiryResponseTransmitPowerLevel),
                        (18,1) => Some(WriteInquiryTransmitPowerLevel),
                        (18,2) => Some(ReadDefaultErroneousDataReporting),
                        (18,3) => Some(WriteDefaultErroneousDataReporting),
                        (18,7) => Some(IOCapabilityRequestReply),
                        (19,0) => Some(UserConfirmationRequestReply),
                        (19,1) => Some(UserConfirmationRequestNegativeReply),
                        (19,2) => Some(UserPasskeyRequestReply),
                        (19,3) => Some(UserPasskeyRequestNegativeReply),
                        (19,4) => Some(RemoteOOBDataRequestReply),
                        (19,5) => Some(WriteSimplePairingDebugMode),
                        (19,6) => Some(EnhancedFlush),
                        (19,7) => Some(RemoteOOBDataRequestNagativeReply),
                        (20,2) => Some(SendKeypressNotification),
                        (20,3) => Some(IOCapabilityRequestNegativeReply),
                        (20,4) => Some(ReadEncryptionKeySize),
                        (21,0) => Some(CreatePhysicalLink),
                        (21,1) => Some(AcceptPhysicalLink),
                        (21,2) => Some(DisconnectPhysicalLink),
                        (21,3) => Some(CreateLogicalLink),
                        (21,4) => Some(AcceptLogicalLink),
                        (21,5) => Some(DisconnectLogicalLink),
                        (21,6) => Some(LogicalLinkCancel),
                        (21,7) => Some(FlowSpecModify),
                        (22,0) => Some(ReadLogicalLinkAcceptTimeout),
                        (22,1) => Some(WriteLogicalLinkAcceptTimeout),
                        (22,2) => Some(SetEventMaskPage2),
                        (22,3) => Some(ReadLocationData),
                        (22,4) => Some(WRiteLocationData),
                        (22,5) => Some(ReadLocalAMPInfo),
                        (22,6) => Some(ReadLocalAMPASSOC),
                        (22,7) => Some(WriteRemoteAMPASSOC),
                        (23,0) => Some(READFlowControlMode),
                        (23,1) => Some(WriteFlowControlMode),
                        (23,2) => Some(ReadDataBlockSize),
                        (23,5) => Some(EnableAMPReceiverReports),
                        (23,6) => Some(AMPTestEnd),
                        (23,7) => Some(AmPTest),
                        (24,0) => Some(ReadEnhancedTransmitPowerLevel),
                        (24,2) => Some(ReadBestEffortFlushTimeout),
                        (24,3) => Some(WriteBestEffortFlushTimeout),
                        (24,4) => Some(ShortRangeMode),
                        (24,5) => Some(ReadLEHostSupport),
                        (24,6) => Some(WriteLEHostSupport),
                        (25,0) => Some(LESetEventMask),
                        (25,1) => Some(LEReadBufferSize),
                        (25,2) => Some(LEReadLocalSupportedFeatures),
                        (25,4) => Some(LESetRandomAddress),
                        (25,5) => Some(LESetAdvertisingParameters),
                        (25,6) => Some(LEReadAdvertisingChannelTXPower),
                        (25,7) => Some(LESetAdvertisingData),
                        (26,0) => Some(LESetScanResponseData),
                        (26,1) => Some(LESetAdvertisingEnable),
                        (26,2) => Some(LESetScanParameters),
                        (26,3) => Some(LESetScanEnable),
                        (26,4) => Some(LECreateConnection),
                        (26,5) => Some(LECreateConnectionCancel),
                        (26,6) => Some(LEReadWhiteListSize),
                        (26,7) => Some(LEClearWhiteList),
                        (27,0) => Some(LEAddDeviceToWhiteList),
                        (27,1) => Some(LERemoveDeviceFromWhiteList),
                        (27,2) => Some(LEConnectionUpdate),
                        (27,3) => Some(LESetHostChannelClassification),
                        (27,4) => Some(LEReadChannelMap),
                        (27,5) => Some(LEReadRemoteFeatures),
                        (27,6) => Some(LEEncrypt),
                        (27,7) => Some(LERand),
                        (28,0) => Some(LEStartEncryption),
                        (28,1) => Some(LELongTermKeyRequestReply),
                        (28,2) => Some(LELongTermKeyRequestNegativeReply),
                        (28,3) => Some(LEReadSupportedStates),
                        (28,4) => Some(LEReceiverTest),
                        (28,5) => Some(LETransmitterTest),
                        (28,6) => Some(LETestEnd),
                        (29,3) => Some(EnhancedSetupSynchronousConnection),
                        (29,4) => Some(EnhancedAcceptSynchronousConnection),
                        (29,5) => Some(ReadLocalSupportedCondecs),
                        (29,6) => Some(SetMWSChannelParameters),
                        (29,7) => Some(SetExternalFrameConfiguration),
                        (30,0) => Some(SetMWSSignaling),
                        (30,1) => Some(SetMWSTransportLayer),
                        (30,2) => Some(SetMWSScanFrequencyTable),
                        (30,3) => Some(GetMWSTransportLayerConfiguration),
                        (30,4) => Some(SetMWSPATTERNConfiguration),
                        (30,5) => Some(SetTriggeredClockCapture),
                        (30,6) => Some(TruncatedPage),
                        (30,7) => Some(TruncatedPageCancel),
                        (31,0) => Some(SetConnectionlessSlaveBroadcast),
                        (31,1) => Some(SetConnectionlessSlaveBroadcastReceive),
                        (31,2) => Some(StartSynchronizationTrain),
                        (31,3) => Some(ReceiveSynchronizationTrain),
                        (31,4) => Some(SetReservedLTADDR),
                        (31,5) => Some(DeleteReservedLTADDR),
                        (31,6) => Some(SetConnectionlessSlaveBroadcastData),
                        (31,7) => Some(ReadSynchronizationTrainParameters),
                        (32,0) => Some(WriteSynchronizationTrainParameters),
                        (32,1) => Some(RemoteOOBExtendedDataRequestReply),
                        (32,2) => Some(ReadSecureConnectionsHostSupport),
                        (32,3) => Some(WriteSecureConnectionsHostSupport),
                        (32,4) => Some(ReadAuthenticatedPayloadTimeout),
                        (32,5) => Some(WriteAuthenticatedPayloadTimeout),
                        (32,6) => Some(ReadLocalOOBExtendedData),
                        (32,7) => Some(WriteSecureConnectionsTestMode),
                        (33,0) => Some(ReadExtendedPageTimeout),
                        (33,1) => Some(WriteExtendedPageTimeout),
                        (33,2) => Some(ReadExtendedInquiryLength),
                        (33,3) => Some(WriteExtendedInquiryLengh),
                        (33,4) => Some(LERemoteConnectionParameterRequestReply),
                        (33,5) => Some(LERemoteConnectionParameterREquestNegativeReply),
                        (33,6) => Some(LESetDataLength),
                        (33,7) => Some(LEReadSuggestedDefaultDataLength),
                        (34,0) => Some(LEWriteSuggestedDefaultDataLength),
                        (34,1) => Some(LEReadLocalP256PublicKey),
                        (34,2) => Some(LEGenerateDHKey),
                        (34,3) => Some(LEAddDeviceToResolvingList),
                        (34,4) => Some(LERemoveDeviceFromResolvingList),
                        (34,5) => Some(LEClearResolvingList),
                        (34,6) => Some(LEReadResolvingListSize),
                        (34,7) => Some(LEReadPeerResolvableAddress),
                        (35,0) => Some(LEReadLocalResolvableAddress),
                        (35,1) => Some(LESetAddressResolutionEnable),
                        (35,2) => Some(LESetResolvablePrivateAddressTimeout),
                        (35,3) => Some(LEReadMaximumDataLength),
                        (35,4) => Some(LEReadPHYCommand),
                        (35,5) => Some(LESetDefaultPHYCommand),
                        (35,6) => Some(LESetPHYCommand),
                        (35,7) => Some(LEEnhancedReceiverTestCommand),
                        (36,0) => Some(LEEnhancedTransmitterTestCommand),
                        (36,1) => Some(LESetAdvertisingSetRandomAddressCommand),
                        (36,2) => Some(LESetExtendedAdvertisingParametersCommand),
                        (36,3) => Some(LESetExtendedAdvertisingDataCommand),
                        (36,4) => Some(LESetExtendedScanResponseDataCommand),
                        (36,5) => Some(LESetExtendedAdvertisingEnableCommand),
                        (36,6) => Some(LEReadMaximumAdvertisingDataLengthCommand),
                        (36,7) => Some(LEReadNumberOfSupportedAdvertisingSetCommand),
                        (37,0) => Some(LERemoveAdvertisingSetCommand),
                        (37,1) => Some(LEClearAdvertisingSetsCommand),
                        (37,2) => Some(LESetPeriodicAdvertisingParametersCommand),
                        (37,3) => Some(LESetPeriodicAdvertisingDataCommand),
                        (37,4) => Some(LESetPeriodicAdvertisingEnableCommand),
                        (37,5) => Some(LESetExtendedScanParametersCommand),
                        (37,6) => Some(LESetExtendedScanEnableCommand),
                        (37,7) => Some(LEExtendedCreateConnectionCommand),
                        (38,0) => Some(LEPeriodicAdvertisingCreateSyncCommand),
                        (38,1) => Some(LEPeriodicAdvertisingCreateSyncCancelCommand),
                        (38,2) => Some(LEPeriodicAdvertisingTerminateSyncCommand),
                        (38,3) => Some(LEAddDeviceToPeriodicAdvertiserListCommand),
                        (38,4) => Some(LERemoveDeviceFromPeriodicAdvertiserListCommand),
                        (38,5) => Some(LEClearPeriodicAdvertiserListCommand),
                        (38,6) => Some(LEReadPeriodicAdvertiserListSizeCommand),
                        (38,7) => Some(LEReadTransmitPowerCommand),
                        (39,0) => Some(LEReadRFPathCompensationCommand),
                        (39,1) => Some(LEWriteRFPathCompensationCommand),
                        (39,2) => Some(LESetPrivacyMode),
                        _      => None
                    }
                }

                // TODO re-make this private
                pub(crate) fn try_from( packed: read_local_commands_rp ) -> Result<Vec<Self>, error::Error> {

                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {

                        let mut sup_commands = Vec::new();

                        let raw = &packed.commands;

                        for indx in 0..raw.len() {
                            for bit in 0..8 {
                                if 0 != raw[indx] & (1 << bit) {
                                    if let Some(command) = Self::from_bit_pos((indx,bit)) {
                                        sup_commands.push(command);
                                    }
                                }
                            }
                        }

                        Ok(sup_commands)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_READ_LOCAL_COMMANDS,
                OGF_INFO_PARAM,
                read_local_commands_rp,
                SupportedCommands,
                Vec<SupportedCommands>,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_INFO_PARAM as u16;
                const OCF: u16 = OCF_READ_LOCAL_COMMANDS as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!()  {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;
                use test::Bencher;

                #[test]
                fn ip_read_local_supported_commands_test() {
                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    ).unwrap();

                    command_complete_test!(result, SupportedCommands);
                }

                #[bench]
                fn ip_read_local_supported_commands_bench( b: &mut Bencher ) {
                    let hci = HostInterface::default();

                    b.iter(|| { block_for_command_result(send(&hci).unwrap()) });
                }

                #[bench]
                /// The hope is that converting the raw bits to a vector of commands is much faster
                /// then the response from the controller (which is what
                /// ip_read_local_supported_features_bench does)
                fn supported_commands_from_raw_bench( b: &mut Bencher) {

                    // Should be the worse than the worst case from the hci return for
                    // performance reasons.
                    let test_data = read_local_commands_rp {
                        status : 0,
                        commands: [0xFFu8;64], // worst case scenerio
                    };

                    b.iter(|| { SupportedCommands::try_from(test_data) } );
                }
            }
        }
    }

    pub mod transmitter {
        pub mod read_advertising_channel_tx_power {
            use bluez::{
                le_read_advertising_channel_tx_power_rp,
                OCF_LE_READ_ADVERTISING_CHANNEL_TX_POWER,
                OGF_LE_CTL,
            };
            use hci::*;

            /// The LE Read Advertising Channel Tx Power Command returns dBm, a unit of power
            /// provided to the radio antenna.
            #[derive(Debug)]
            pub struct TxPower(i8);

            impl TxPower {

                fn try_from(packed: le_read_advertising_channel_tx_power_rp) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(TxPower(packed.level))
                    }
                    else {
                        Err(status)
                    }
                }

                pub fn into_milli_watts(&self) -> f32 {
                    use core::f32;
                    10f32.powf( self.0 as f32 / 10f32 )
                }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_ADVERTISING_CHANNEL_TX_POWER,
                OGF_LE_CTL,
                le_read_advertising_channel_tx_power_rp,
                TxPower,
                error::Error
            );

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_ADVERTISING_CHANNEL_TX_POWER as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_advertising_channel_tx_power_test() {
                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, TxPower);
                }

                #[test]
                fn tx_power_into_watts_test() {
                    // just some data from wikipedia's dBm page
                    let test_data = [(29i8, 794f32), (24i8,251f32), (-20i8, 10E-6f32)];

                    let fudge_factor = 0.5;

                    let fudge = | act: f32, exp: f32 | {
                        ( exp + fudge_factor > act ) && ( exp - fudge_factor < act )
                    };

                    let dbg_out = | act, exp | {
                        format!("act: {:?}, exp: {:?}, fudge: {:?}", act, exp, fudge_factor)
                    };

                    for (dbm, exp_mw) in test_data.iter() {
                        let act_mw = TxPower(*dbm).into_milli_watts();

                        assert!(fudge(act_mw,*exp_mw), "{}", dbg_out(act_mw,*exp_mw));
                    }
                }
            }
        }
        pub mod transmitter_test{
            use bluez::{
                le_transmitter_test_cp,
                OCF_LE_TRANSMITTER_TEST,
                OGF_LE_CTL,
            };
            use hci::*;
            pub use hci::le::common::Frequency;

            #[cfg_attr(test,derive(Debug))]
            pub enum TestPayload {
                PRBS9Sequence,
                Repeat11110000,
                Repeat10101010,
                PRBS15Sequence,
                Repeat11111111,
                Repeat00000000,
                Repeat00001111,
                Repeat01010101,
            }

            impl TestPayload {
                fn into_val(&self) -> u8 {
                    use self::TestPayload::*;
                    match *self {
                        PRBS9Sequence  => 0x00u8,
                        Repeat11110000 => 0x01u8,
                        Repeat10101010 => 0x02u8,
                        PRBS15Sequence => 0x03u8,
                        Repeat11111111 => 0x04u8,
                        Repeat00000000 => 0x05u8,
                        Repeat00001111 => 0x06u8,
                        Repeat01010101 => 0x07u8,
                    }
                }
            }

            impl_status_return!(OCF_LE_TRANSMITTER_TEST, OGF_LE_CTL);

            impl CommandParameters for le_transmitter_test_cp {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_TRANSMITTER_TEST as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send(
                hci: &HostInterface,
                frequency: Frequency,
                payload: TestPayload,
                payload_length: u8 ) -> hci_return!() {

                let parameters = le_transmitter_test_cp {
                    frequency: frequency.get_val(),
                    length: payload_length,
                    payload: payload.into_val(),
                };

                hci.send_command(parameters, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use hci::le::mandatory::test_end;
                use std::{thread, time};
                use hci::test_util::block_for_command_result;

                #[test]
                #[ignore]
                fn transmitter_test_test() {
                    let hi = HostInterface::default();

                    let payload = TestPayload::Repeat11110000;
                    let frequency = Frequency::new( 2460 ).unwrap();
                    let payload_len = 2u8;

                    let sleep_duration = time::Duration::new(1,0);

                    let result = block_for_command_result(
                        send(&hi, frequency, payload, payload_len).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result,Return);

                    thread::sleep(sleep_duration);

                    block_for_command_result(
                        test_end::send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();
                }
            }
        }
        pub mod set_advertising_data {
            use bluez::{
                le_set_advertising_data_cp,
                OCF_LE_SET_ADVERTISING_DATA,
                OGF_LE_CTL,
            };
            use hci::*;
            use gap::advertise::{ConvertRawData,DataTooLargeError};

            type Payload = [u8;31];

            /// Advertising data
            ///
            /// The Adevertising data is made up of AD Structs. The maximum amount of bytes a
            /// regular advertising broadcast can send is 30 bytes (look at extended
            /// advertising for a larger payload). The total payload is 1 byte for the length,
            /// and 30 bytes for the AD structures. The data can consist of as many AD structs
            /// that can fit in it, but it must consist of at least one AD struct (unless
            /// early termination is desired).
            #[derive(Debug,Clone,Copy)]
            pub struct AdvertisingData {
                length: usize,
                payload: Payload,
            }

            impl AdvertisingData {

                /// Create an empty advertising data
                ///
                /// This is exactly the same as the function early_terminate, but makes more
                /// "readable" sense to use this in conjuntion with try_push.
                #[inline]
                pub fn new() -> Self {
                    Self::early_terminate()
                }

                /// Ealy termination of advertising
                ///
                /// This can also be use to build AdvertisingData object from an "empty" state,
                /// but it is recommended to use the try_from method.
                ///
                /// ```rust
                /// use bo_tie_linux::hci::le::transmitter::command::set_advertising_data::{ADStruct,AdvertisingData};
                ///
                /// // try to use the try_from method instead of doing it this way.
                /// let mut ad = AdvertisingData::early_terminate();
                ///
                /// ad.try_push( ADStruct {ad_type: 0x01u8, data: &[0x00u8]} ).unwrap();
                /// ```
                pub fn early_terminate() -> Self {
                    AdvertisingData{
                        length: 0,
                        payload: Payload::default(),
                    }
                }

                /// Add an ADStruct to the advertising data
                ///
                /// Returns self if the data was added to the advertising data
                ///
                /// # Error
                /// 'data' in its transmission form was too large for remaining free space in
                /// the advertising data.
                pub fn try_push<T>(&mut self, data: T )
                    -> Result<(), DataTooLargeError>
                    where T: ConvertRawData
                {
                    let raw_data = data.into_raw();

                    if raw_data.len() + self.length <= self.payload.len() {
                        let old_len = self.length;

                        self.length += raw_data.len();

                        self.payload[old_len..self.length].copy_from_slice(&raw_data);

                        Ok(())
                    }
                    else {
                        Err(DataTooLargeError {
                            overflow: raw_data.len() + self.length - self.payload.len(),
                            remaining: self.payload.len() - self.length,
                        })
                    }
                }

                /// Get the remaining amount of space available for ADStructures
                ///
                /// Use this to get the remaining space that can be sent in an advertising
                /// packet.
                pub fn remaining_space(&self) -> usize {
                    self.payload.len() - self.length as usize
                }
            }

            impl CommandParameters for AdvertisingData{
                type Parameter = le_set_advertising_data_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_ADVERTISING_DATA as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_set_advertising_data_cp {
                        length: self.length as u8,
                        data: self.payload,
                    }
                }
            }

            impl_status_return!(OCF_LE_SET_ADVERTISING_DATA, OGF_LE_CTL);

            pub fn send( hci: &HostInterface, adv_data: AdvertisingData ) -> hci_return!() {
                hci.send_command(adv_data, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn set_advertising_data_test() {

                    use gap::advertise::{flags,local_name};

                    let mut flags = flags::Flags::new();

                    flags.get_user(0).enable();
                    flags.get_user(20).enable();

                    let local_name = local_name::LocalName::new("Test", false);

                    let mut ad = AdvertisingData::new();
                    ad.try_push(flags).unwrap();
                    ad.try_push(local_name).unwrap();

                    let result = block_for_command_result(
                        send(&HostInterface::default(), ad).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }

                #[test]
                fn advertising_data_try_from_test () {

                    use gap::advertise::{flags,local_name};

                    let mut flags = flags::Flags::new();

                    flags.get_user(11).enable();
                    flags.get_user(8*3).enable();

                    let too_long_name = local_name::LocalName::new("Supercalifragilisticexpialidocious", true);

                    AdvertisingData::new()
                    .try_push(flags)
                    .unwrap();

                    AdvertisingData::new()
                    .try_push(too_long_name)
                    .unwrap_err();
                }

                #[test]
                fn advertising_data_try_push_test () {
                    use gap::advertise::local_name::LocalName;
                    use std::str::from_utf8;

                    let local_name_1 = LocalName::new("abcdefghijklm", true);
                    let local_name_2 = LocalName::new("012345678901234", false);
                    let local_name_too_long = LocalName::new(from_utf8(&[102u8;31]).unwrap(), false);

                    let mut test_ad_1 = AdvertisingData::early_terminate();
                    let mut test_ad_2 = AdvertisingData::early_terminate();

                    assert!(test_ad_1.try_push( local_name_1 ).is_ok());

                    assert!(test_ad_1.try_push( local_name_2 ).is_err());

                    assert!(test_ad_2.try_push( local_name_too_long ).is_err());
                }
            }
        }
        pub mod set_advertising_enable {
            use bluez::{
                le_set_advertise_enable_cp,
                OCF_LE_SET_ADVERTISE_ENABLE,
                OGF_LE_CTL,
            };
            use hci::*;

            impl_status_return!(OCF_LE_SET_ADVERTISE_ENABLE, OGF_LE_CTL);

            #[derive(Clone,Copy)]
            struct Parameter{
                enable: bool
            }

            impl CommandParameters for Parameter {
                type Parameter = le_set_advertise_enable_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_ADVERTISE_ENABLE as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_set_advertise_enable_cp {
                        enable: if self.enable { 1 } else { 0 }
                    }
                }
            }

            pub fn send( hci: &HostInterface, enable: bool ) -> hci_return!() {
                hci.send_command(Parameter{ enable: enable }, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use super::super::set_advertising_data;
                use hci::test_util::block_for_command_result;

                #[test]
                fn set_advertising_enable_test() {
                    use gap::advertise::local_name::LocalName;

                    let hci = HostInterface::default();

                    let mut payload = set_advertising_data::AdvertisingData::new();

                    payload.try_push(LocalName::new("ENABLE BLE TEST", true)).unwrap();

                    block_for_command_result(
                        set_advertising_data::send(&hci, payload).unwrap()
                    )
                    .unwrap();

                    let result_1 = block_for_command_result(
                        send(&hci, true).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result_1, Return);

                    let result_2 = block_for_command_result(
                        send(&hci, false).unwrap()
                    ).unwrap();

                    command_complete_test!(result_2, Return);

                }
            }
        }
        pub mod set_advertising_parameters {
            use bluez::{
                le_set_advertising_parameters_cp,
                OCF_LE_SET_ADVERTISING_PARAMETERS,
                OGF_LE_CTL,
            };
            use hci::*;
            pub use hci::le::common::OwnAddressType;
            use core::default::Default;

            interval!( AdvertisingInterval, 0x0020, 0x4000, 0x0800, 625);

            /// Advertising Type
            ///
            /// Enumeration for the 'Advertising Type' advertising parameter.
            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingType {
                ConnectableAndScannableUndirectedAdvertising,
                ConnectableHighDucyCycleDirectedAdvertising,
                ScannableUndirectedAdvertising,
                NonConnectableUndirectedAdvertising,
                ConnectableLowDutyCycleDirectedAdvertising,
            }

            impl AdvertisingType {

                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingType::ConnectableAndScannableUndirectedAdvertising => 0x00,
                        AdvertisingType::ConnectableHighDucyCycleDirectedAdvertising => 0x01,
                        AdvertisingType::ScannableUndirectedAdvertising => 0x02,
                        AdvertisingType::NonConnectableUndirectedAdvertising => 0x03,
                        AdvertisingType::ConnectableLowDutyCycleDirectedAdvertising => 0x04,
                    }
                }
            }

            impl Default for AdvertisingType {
                fn default() -> Self {
                    AdvertisingType::ConnectableAndScannableUndirectedAdvertising
                }
            }

            /// Peer address type
            ///
            /// # Notes (from core 5.0 specification)
            /// - PublicAddress -> Public Device Address (default) or Public Identity Address
            /// - RandomAddress -> Random Device Address or Random (static) Identity Address
            #[cfg_attr(test,derive(Debug))]
            pub enum PeerAddressType {
                PublicAddress,
                RandomAddress,
            }

            impl PeerAddressType {
                fn into_val(&self) -> u8 {
                    match *self {
                        PeerAddressType::PublicAddress => 0x00,
                        PeerAddressType::RandomAddress => 0x01,
                    }
                }
            }

            impl Default for PeerAddressType {
                fn default() -> Self {
                    PeerAddressType::PublicAddress
                }
            }

            /// Advertising channels
            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingChannel {
                Channel37,
                Channel38,
                Channel39,
            }

            impl AdvertisingChannel {
                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingChannel::Channel37 => 0x01,
                        AdvertisingChannel::Channel38 => 0x02,
                        AdvertisingChannel::Channel39 => 0x04,
                    }
                }

                pub fn default_channels() -> &'static [AdvertisingChannel] {
                    &[
                        AdvertisingChannel::Channel37,
                        AdvertisingChannel::Channel38,
                        AdvertisingChannel::Channel39,
                    ]
                }
            }

            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingFilterPolicy {
                AllDevices,
                AllConnectionRequestsWhitlistedDeviceScanRequests,
                AllScanRequestsWhitlistedDeviceConnectionRequests,
                WhitelistedDevices,
            }

            impl AdvertisingFilterPolicy {
                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingFilterPolicy::AllDevices => 0x00,
                        AdvertisingFilterPolicy::AllConnectionRequestsWhitlistedDeviceScanRequests => 0x01,
                        AdvertisingFilterPolicy::AllScanRequestsWhitlistedDeviceConnectionRequests => 0x02,
                        AdvertisingFilterPolicy::WhitelistedDevices => 0x03,
                    }
                }
            }

            impl Default for AdvertisingFilterPolicy {
                fn default() -> Self {
                    AdvertisingFilterPolicy::AllDevices
                }
            }

            /// All the parameters required for advertising
            ///
            /// For the advertising_channel_map, provide a slice containing every channels
            /// desired to be advertised on.
            ///
            /// While most members are public, the only way to set the minimum and maximum
            /// advertising interval is through method calls.
            #[cfg_attr(test,derive(Debug))]
            pub struct AdvertisingParameters<'a> {
                pub minimum_advertising_interval: AdvertisingInterval,
                pub maximum_advertising_interval: AdvertisingInterval,
                pub advertising_type: AdvertisingType,
                pub own_address_type: OwnAddressType,
                pub peer_address_type: PeerAddressType,
                pub peer_address: ::BluetoothDeviceAddress,
                pub advertising_channel_map: &'a[AdvertisingChannel],
                pub advertising_filter_policy: AdvertisingFilterPolicy,
            }

            impl<'a> Default for AdvertisingParameters<'a> {

                /// Create an AdvertisingParameters object with the default parameters (except
                /// for the peer_address member).
                ///
                /// The default parameter values are from the bluetooth core 5.0 specification,
                /// however there is no default value for the peer_address. This function sets
                /// the peer_address to zero, so it must be set after if a connection to a
                /// specific peer device is desired.
                fn default() -> Self {
                    AdvertisingParameters {
                        minimum_advertising_interval: AdvertisingInterval::default(),
                        maximum_advertising_interval: AdvertisingInterval::default(),
                        advertising_type: AdvertisingType::default(),
                        own_address_type: OwnAddressType::default(),
                        peer_address_type: PeerAddressType::default(),
                        peer_address: [0u8;6].into(),
                        advertising_channel_map: AdvertisingChannel::default_channels(),
                        advertising_filter_policy: AdvertisingFilterPolicy::default(),
                    }
                }
            }

            impl<'a> AdvertisingParameters<'a> {

                /// Create the default parameters except use the specified bluetooth device
                /// address for the peer_address member
                pub fn default_with_peer_address( addr: &'a ::BluetoothDeviceAddress) ->
                        AdvertisingParameters
                {
                    let mut ap = AdvertisingParameters::default();

                    ap.peer_address = *addr;

                    ap
                }
            }

            impl CommandParameters for le_set_advertising_parameters_cp{
                type Parameter = le_set_advertising_parameters_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_ADVERTISING_PARAMETERS as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_status_return!(OCF_LE_SET_ADVERTISING_PARAMETERS, OGF_LE_CTL);

            pub fn send( hci: &HostInterface, params: AdvertisingParameters ) -> hci_return!() {

                let parameter = le_set_advertising_parameters_cp {

                    min_interval: params.minimum_advertising_interval.get_raw_val(),

                    max_interval: params.maximum_advertising_interval.get_raw_val(),

                    advtype: params.advertising_type.into_val(),

                    own_bdaddr_type: params.own_address_type.into_val(),

                    direct_bdaddr_type: params.peer_address_type.into_val(),

                    direct_bdaddr: params.peer_address.into(),

                    chan_map: params.advertising_channel_map.iter().fold(0u8, |v, x| v | x.into_val()),

                    filter: params.advertising_filter_policy.into_val(),
                };

                hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::time::Duration;
                use hci::test_util::block_for_command_result;

                #[test]
                fn advertising_interval_test() {

                    AdvertisingInterval::try_from_raw(0x0020).unwrap();

                    AdvertisingInterval::try_from_raw(0x0019).unwrap_err();

                    AdvertisingInterval::try_from_raw(0x4000).unwrap();

                    AdvertisingInterval::try_from_raw(0x4001).unwrap_err();

                    AdvertisingInterval::try_from_duration(Duration::from_millis(20)).unwrap();

                    AdvertisingInterval::try_from_duration(Duration::from_nanos(19999999)).unwrap_err();

                    AdvertisingInterval::try_from_duration(Duration::new(10, 24000000)).unwrap();

                    AdvertisingInterval::try_from_duration(Duration::new(10, 24000001)).unwrap();
                }

                #[test]
                fn set_advertising_parameters_test() {
                    let params = AdvertisingParameters::default_with_peer_address(&[0x12;6]);

                    let result = block_for_command_result (
                        send( &HostInterface::default(), params).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }

            }
        }
        pub mod set_random_address {
            use bluez::{
                bdaddr_t,
                le_set_random_address_cp,
                OCF_LE_SET_RANDOM_ADDRESS,
                OGF_LE_CTL,
            };
            use hci::*;

            impl_status_return!(OCF_LE_SET_RANDOM_ADDRESS, OGF_LE_CTL);

            struct Parameter {
                rand_address: ::BluetoothDeviceAddress
            }

            impl CommandParameters for Parameter {
                type Parameter = le_set_random_address_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_RANDOM_ADDRESS as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_set_random_address_cp {
                        bdaddr: bdaddr_t {
                            b: self.rand_address
                        }
                    }
                }
            }

            pub fn send( hci: &HostInterface, rand_addr: ::BluetoothDeviceAddress ) ->
                hci_return!()
            {
                hci.send_command(Parameter{ rand_address: rand_addr }, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests{

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn set_random_address_test() {

                    let static_address_flag = 0b00000011;

                    let addr = [0x11,0x22,0x33,0x44,0x55,0x66 | static_address_flag];

                    let result = block_for_command_result(
                        send(&HostInterface::default(), addr).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
    }

    pub mod receiver {
        pub mod receiver_test {
            use bluez::{
                le_receiver_test_cp,
                OCF_LE_RECEIVER_TEST,
                OGF_LE_CTL,
            };
            use hci::*;
            pub use hci::le::common::Frequency;

            impl_status_return!(OCF_LE_RECEIVER_TEST, OGF_LE_CTL);

            impl CommandParameters for Frequency
            {
                type Parameter = le_receiver_test_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_RECEIVER_TEST as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_receiver_test_cp {
                        frequency: self.get_val()
                    }
                }
            }

            pub fn send( hci: &HostInterface, frequency: Frequency ) -> hci_return!()
            {
                hci.send_command(frequency, events::Events::CommandComplete , Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                #[ignore]
                fn receiver_test_command_test() {

                    let frequency = Frequency::new(2420).unwrap();

                    let result = block_for_command_result(
                        send(&HostInterface::default(), frequency).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
        pub mod set_scan_enable {
            use bluez::{
                le_set_scan_enable_cp,
                OCF_LE_SET_SCAN_ENABLE,
                OGF_LE_CTL,
            };
            use hci::*;

            impl_status_return!(OCF_LE_SET_SCAN_ENABLE, OGF_LE_CTL);

            struct Parameter {
                enable: bool,
                filter_duplicates: bool,
            }

            impl CommandParameters for Parameter {
                type Parameter = le_set_scan_enable_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_SCAN_ENABLE as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_set_scan_enable_cp {
                        enable: if self.enable {1} else {0},
                        filter_dup: if self.filter_duplicates {1} else {0},
                    }
                }
            }

            /// The command has the ability to enable/disable scanning and filter duplicate
            /// advertisement.
            pub fn send( hci: &HostInterface, enable: bool, filter_duplicates: bool) ->
                hci_return!()
            {
                let cmd_param = Parameter {
                    enable: enable,
                    filter_duplicates: filter_duplicates,
                };

                hci.send_command(cmd_param, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn set_scan_enable_test() {

                    #![allow(unreachable_code)]
                    panic!("Test not written correctly");

                    let hci = HostInterface::default();

                    let result_1 = block_for_command_result(
                        send(&hci, true, true).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result_1, Return);

                    command_complete_test!(
                        block_for_command_result(
                            send(&hci, true, true).unwrap()
                        ).unwrap(),
                        Return
                    );

                    command_complete_test!(
                        block_for_command_result(
                            send(&hci, false, true).unwrap()
                        ).unwrap(),
                        Return
                    );


                    command_complete_test!(
                        block_for_command_result(
                            send(&hci, false, false).unwrap()
                        ).unwrap(),
                        Return
                    );
                }
            }
        }
        pub mod set_scan_parameters {
            use bluez::{
                le_set_scan_parameters_cp,
                OCF_LE_SET_SCAN_PARAMETERS,
                OGF_LE_CTL,
            };
            use hci::*;
            pub use hci::le::common::OwnAddressType;

            interval!( ScanningInterval, 0x0004, 0x4000, 0x0010, 625);

            pub enum LEScanType {
                PassiveScanning,
                ActiveScanning,
            }

            impl LEScanType {
                fn into_val(&self) -> u8 {
                    match *self {
                        LEScanType::PassiveScanning => 0x00,
                        LEScanType::ActiveScanning  => 0x01,
                    }
                }
            }

            impl Default for LEScanType {
                fn default() -> Self {
                    LEScanType::PassiveScanning
                }
            }

            /// See the spec on this one (v5.0 | Vol 2, Part E, 7.8.10) to understand what
            /// the enumerations are representing.
            ///
            /// Value mapping
            /// 0x00 => AcceptAll
            /// 0x01 => WhiteListed
            /// 0x02 => AcceptAllExceptIdentityNotAddressed
            /// 0x03 => AcceptAllExceptIdentityNotInWhitelist
            pub enum ScanningFilterPolicy {
                AcceptAll,
                WhiteListed,
                AcceptAllExceptIdentityNotAddressed,
                AcceptAllExceptIdentityNotInWhitelist,
            }

            impl ScanningFilterPolicy {
                fn into_val(&self) -> u8 {
                    match *self {
                        ScanningFilterPolicy::AcceptAll => 0x00,
                        ScanningFilterPolicy::WhiteListed => 0x01,
                        ScanningFilterPolicy::AcceptAllExceptIdentityNotAddressed => 0x02,
                        ScanningFilterPolicy::AcceptAllExceptIdentityNotInWhitelist => 0x03,
                    }
                }
            }

            impl Default for ScanningFilterPolicy {
                fn default() -> Self {
                    ScanningFilterPolicy::AcceptAll
                }
            }

            pub struct ScanningParameters {
                scan_type: LEScanType,
                scan_interval: ScanningInterval,
                scan_window: ScanningInterval,
                own_address_type: OwnAddressType,
                scanning_filter_policy: ScanningFilterPolicy,
            }

            impl Default for ScanningParameters {
                fn default() -> Self {
                    ScanningParameters {
                        scan_type: LEScanType::default(),
                        scan_interval: ScanningInterval::default(),
                        scan_window: ScanningInterval::default(),
                        own_address_type: OwnAddressType::default(),
                        scanning_filter_policy: ScanningFilterPolicy::default(),
                    }
                }
            }

            impl_status_return!(OCF_LE_SET_SCAN_PARAMETERS, OGF_LE_CTL);

            impl CommandParameters for ScanningParameters {
                type Parameter = le_set_scan_parameters_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_SCAN_PARAMETERS as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_set_scan_parameters_cp {
                        type_:           self.scan_type.into_val(),
                        interval:        self.scan_interval.get_raw_val(),
                        window:          self.scan_window.get_raw_val(),
                        own_bdaddr_type: self.own_address_type.into_val(),
                        filter:          self.scanning_filter_policy.into_val(),
                    }
                }
            }

            pub fn send( hci: &HostInterface, sp: ScanningParameters ) -> hci_return!()
            {
                hci.send_command(sp, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::time::Duration;
                use hci::test_util::block_for_command_result;

                #[test]
                fn scanning_interval_test() {
                    ScanningInterval::try_from_raw(0x0004).unwrap();
                    ScanningInterval::try_from_raw(0x4000).unwrap();
                    ScanningInterval::try_from_raw(0x0003).unwrap_err();
                    ScanningInterval::try_from_raw(0x4001).unwrap_err();
                    ScanningInterval::try_from_duration(Duration::from_micros(2500)).unwrap();
                    ScanningInterval::try_from_duration(Duration::new(10,240000000)).unwrap();
                    ScanningInterval::try_from_duration(Duration::from_nanos(2499999)).unwrap_err();
                    ScanningInterval::try_from_duration(Duration::new(10,240000001)).unwrap_err();
                }

                #[test]
                fn set_scan_parameters_test() {

                    let parameters = ScanningParameters::default();

                    let result = block_for_command_result(
                        send(&HostInterface::default(), parameters).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
    }

    pub mod connection {

        use hci::common::LEConnectionInterval;

        pub struct ConnectionEventLength {
            minimum: u16,
            maximum: u16,
        }

        impl ConnectionEventLength {
            pub fn new(min: u16, max: u16) -> Self {
                Self {
                    minimum: min,
                    maximum: max
                }
            }
        }

        impl ::core::default::Default for ConnectionEventLength {
            fn default() -> Self {
                Self {
                    minimum: 0,
                    maximum: 0xFFFF,
                }
            }
        }

        /// ConnectionUpdateInterval contaings the minimum and maximum connection intervals for
        /// the le connection update
        pub struct ConnectionInterval {
            min: LEConnectionInterval,
            max: LEConnectionInterval,
        }

        impl ConnectionInterval {
            /// Create a ConnectionUpdateInterval
            ///
            /// # Errors
            /// An error is returned if the minimum is greater then the maximum
            pub fn try_from(min: LEConnectionInterval, max: LEConnectionInterval)
                -> Result<Self,&'static str>
            {
                if min.get_interval() <= max.get_interval() {
                    Ok( Self {
                        min: min,
                        max: max,
                    })
                }
                else {
                    Err("Connection interval min > max")
                }
            }
        }

        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod disconnect {
            use bluez::{
                disconnect_cp,
                OCF_DISCONNECT,
                OGF_LINK_CTL,
            };
            use hci::*;
            use hci::common::ConnectionHandle;

            /// These are the error codes that are given as reasons for disconnecting
            ///
            /// These enumerations are the acceptable error codes to be used as reasons for
            /// triggering the disconnect.
            pub enum DisconnectReason {
                AuthenticationFailure,
                RemoteUserTerminatedConnection,
                RemoteDeviceTerminatedConnectionDueToLowResources,
                RemoteDeviceTerminatedConnectionDueToPowerOff,
                UnsupportedRemoteFeature,
                PairingWithUnitKeyNotSupported,
                UnacceptableConnectionParameters,
            }

            impl DisconnectReason {

                // TODO implement when HCI error codes are added, and add parameter for the
                // error enumeraton name
                pub fn try_from_hci_error( error: error::Error ) -> Result<DisconnectReason, &'static str> {
                    match error {
                        error::Error::AuthenticationFailure => {
                            Ok(DisconnectReason::AuthenticationFailure)
                        }
                        error::Error::RemoteUserTerminatedConnection => {
                            Ok(DisconnectReason::RemoteUserTerminatedConnection)
                        }
                        error::Error::RemoteDeviceTerminatedConnectionDueToLowResources => {
                            Ok(DisconnectReason::RemoteDeviceTerminatedConnectionDueToLowResources)
                        }
                        error::Error::RemoteDeviceTerminatedConnectionDueToPowerOff => {
                            Ok(DisconnectReason::RemoteDeviceTerminatedConnectionDueToPowerOff)
                        }
                        error::Error::UnsupportedRemoteFeatureOrUnsupportedLMPFeature => {
                            Ok(DisconnectReason::UnsupportedRemoteFeature)
                        }
                        error::Error::PairingWithUnitKeyNotSupported => {
                            Ok(DisconnectReason::PairingWithUnitKeyNotSupported)
                        }
                        error::Error::UnacceptableConnectionParameters => {
                            Ok(DisconnectReason::UnacceptableConnectionParameters)
                        }
                        _ => {
                            Err("No Disconnect reason for error")
                        }
                    }
                }

                fn get_val(&self) -> u8 {
                    match *self {
                        DisconnectReason::AuthenticationFailure => 0x05,
                        DisconnectReason::RemoteUserTerminatedConnection => 0x13,
                        DisconnectReason::RemoteDeviceTerminatedConnectionDueToLowResources => 0x14,
                        DisconnectReason::RemoteDeviceTerminatedConnectionDueToPowerOff => 0x15,
                        DisconnectReason::UnsupportedRemoteFeature => 0x1A,
                        DisconnectReason::PairingWithUnitKeyNotSupported => 0x29,
                        DisconnectReason::UnacceptableConnectionParameters => 0x3B,
                    }
                }
            }

            pub struct DisconnectParameters {
                pub connection_handle: ConnectionHandle,
                pub disconnect_reason: DisconnectReason,
            }

            impl CommandParameters for DisconnectParameters {
                type Parameter = disconnect_cp;
                const OGF: u16 = OGF_LINK_CTL as u16;
                const OCF: u16 = OCF_DISCONNECT as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    disconnect_cp {
                        handle: self.connection_handle.get_raw_handle(),
                        reason: self.disconnect_reason.get_val(),
                    }
                }
            }

            pub fn send( hci: &HostInterface, dp: DisconnectParameters ) -> hci_return!()
            {
                hci.send_command(dp, events::Events::CommandStatus, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn disconnect_test() {
                    // should be a random, unused handle
                    let handle = ConnectionHandle::try_from(0x123).unwrap();

                    let reason = DisconnectReason::AuthenticationFailure;

                    let parameters = DisconnectParameters {
                        connection_handle: handle,
                        disconnect_reason: reason,
                    };


                    let result = block_for_command_result(
                        send(&HostInterface::default(), parameters).unwrap()
                    )
                    .unwrap();

                    match result {
                        events::EventsData::CommandStatus(ref data, ref raw) => {
                            // This is a made up connection handle so this should return an error
                            // for its status parameter
                            if error::Error::UnknownConnectionIdentifier != error::Error::from(data.status) {
                                panic!("Expecting command status error {:?}, found: {:?}; raw data {:?}",
                                    error::Error::UnknownConnectionIdentifier,
                                    error::Error::from(data.status),
                                    raw);
                            }
                        },
                        _ => panic!("Expected Command Status Event"),
                    }
                }
            }
        }
        pub mod connection_update {
            use bluez::{
                le_connection_update_cp,
                OGF_LE_CTL,
                OCF_LE_CONN_UPDATE,
            };
            use hci::*;
            pub use hci::common::{
                ConnectionHandle,
                LEConnectionInterval,
                SupervisionTimeout,
            };
            use super::{ConnectionEventLength, ConnectionInterval};

            pub struct ConnectionUpdate {
                pub handle: ConnectionHandle,
                pub interval: ConnectionInterval,
                pub latency: u16,
                pub supervision_timeout: SupervisionTimeout,
                pub connection_event_len: ConnectionEventLength,
            }


            impl CommandParameters for ConnectionUpdate {
                type Parameter = le_connection_update_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_CONN_UPDATE as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_connection_update_cp {
                        handle:              self.handle.get_raw_handle(),
                        min_interval:        self.interval.min.get_interval(),
                        max_interval:        self.interval.max.get_interval(),
                        latency:             self.latency,
                        supervision_timeout: self.supervision_timeout.get_timeout(),
                        min_ce_length:       self.connection_event_len.minimum,
                        max_ce_length:       self.connection_event_len.maximum,
                    }
                }
            }

            /// The event expected to be returned is the LEMeta event carrying a Connection Update
            /// Complete lE event
            pub fn send( hci: &HostInterface, cu: ConnectionUpdate, timeout: Duration) -> hci_return!() {
                hci.send_command( cu, events::Events::LEMeta, timeout )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use hci::test_util::block_for_command_result;

                /// This will likely fail with a timeout due to there being no connection to
                /// a device.
                #[test]
                fn connection_update_test() {

                    let timeout = Duration::from_secs(1);

                    let parameter = ConnectionUpdate {
                        handle: ConnectionHandle::try_from(0x0033).unwrap(),
                        interval: ConnectionInterval::try_from(
                            LEConnectionInterval::try_from(0x100).unwrap(),
                            LEConnectionInterval::try_from(0x100).unwrap()
                        ).unwrap(),
                        latency: 0x1000,
                        supervision_timeout: SupervisionTimeout::try_from(0x234).unwrap(),
                        connection_event_len: ConnectionEventLength::new(0, 0xFFFF)
                    };

                    let result = block_for_command_result(
                        send(&HostInterface::default(), parameter, timeout).unwrap()
                    )
                    .unwrap();

                    match result {
                        events::EventsData::LEMeta(ref data, _ ) => {
                            match *data {
                                events::LEMetaData::ConnectionUpdateComplete(ref data) => {
                                    if let error::Error::NoError = error::Error::from(data.status) {
                                        panic!("Expected Error because no connection is made");
                                    }
                                },
                                _ => panic!("Expected LE Meta event Connection Update Complete"),
                            }
                        },
                        _ => panic!("Expected LE Meta event"),
                    }
                }
            }
        }
        pub mod create_connection_cancel {
            use bluez::{
                OCF_LE_CREATE_CONN_CANCEL,
                OGF_LE_CTL,
            };
            use hci::*;

            impl_status_return!(OCF_LE_CREATE_CONN_CANCEL, OGF_LE_CTL);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const OCF: u16 = OCF_LE_CREATE_CONN_CANCEL as u16;
                const OGF: u16 = OGF_LE_CTL as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            pub fn send( hci: &HostInterface) -> hci_return!() {
                hci.send_command( Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn create_connection_cancel_test() {

                    let result = block_for_command_result(
                        send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    command_complete_test!(result, Return);
                }
            }
        }
        pub mod create_connection {
            use bluez::{
                bdaddr_t,
                le_create_connection_cp,
                OCF_LE_CREATE_CONN,
                OGF_LE_CTL,
            };
            use super::{ConnectionEventLength, ConnectionInterval};
            use hci::*;
            use hci::common::{
                ConnectionLatency,
                LEAddressType,
                SupervisionTimeout,
                BoundsErr,
            };
            pub use hci::le::common::OwnAddressType;
            use core::time::Duration;

            pub enum InitiatorFilterPolicy {
                DoNotUseWhiteList,
                UseWhiteList,
            }

            impl InitiatorFilterPolicy {
                fn into_raw(&self) -> u8 {
                    match *self {
                        InitiatorFilterPolicy::DoNotUseWhiteList => 0x00,
                        InitiatorFilterPolicy::UseWhiteList => 0x01,
                    }
                }
            }

            pub struct LEScanInterval {
                interval: u16,
            }

            impl LEScanInterval {
                const CNV: u64 = 625; // unit: microseconds
                pub const MIN: u16 = 0x0004;
                pub const MAX: u16 = 0x4000;

                /// Try to create a ScanInterval
                ///
                /// The parameter must be between the constants MIN and MAX
                ///
                /// ``` rust
                /// # use bo_tie_linux::hci::le::ConnectionInterval;
                /// let ci = ConnectionInterval::try_from(0x0027).unwrap();
                /// ```
                ///
                /// # Errors
                /// Will return a ConnectionIntervalErr with the violated bound as above or below the maximum or minimum
                /// interval value
                pub fn try_from(val: u16) -> Result<Self, BoundsErr> {
                    Ok(
                        LEScanInterval {
                            interval: BoundsErr::check(val, Self::MIN, Self::MAX)?
                        }
                    )
                }

                /// Get the minimum interval value as a duration
                pub fn as_duration(&self) -> Duration {
                    Duration::from_micros((self.interval as u64) * Self::CNV)
                }

                pub fn get_interval(&self) -> u16 {
                    self.interval
                }
            }

            pub struct LEScanWindow {
                window: u16,
            }

            impl LEScanWindow {
                const CNV: u64 = 625; // unit: microseconds
                pub const MIN: u16 = 0x0004;
                pub const MAX: u16 = 0x4000;

                /// Try to create a ScanInterval
                ///
                /// The parameter must be between the constants MIN and MAX
                ///
                /// ``` rust
                /// # use bo_tie_linux::hci::le::ConnectionInterval;
                /// let ci = ConnectionInterval::try_from(0x0027).unwrap();
                /// ```
                ///
                /// # Errors
                /// Will return a ConnectionIntervalErr with the violated bound as above or below the maximum or minimum
                /// interval value
                pub fn try_from(val: u16) -> Result<Self, BoundsErr> {
                    Ok(
                        LEScanWindow {
                            window: BoundsErr::check(val, Self::MIN, Self::MAX)?
                        }
                    )
                }

                /// Get the minimum interval value as a duration
                pub fn as_duration(&self) -> Duration {
                    Duration::from_micros((self.window as u64) * Self::CNV)
                }

                pub fn get_window(&self) -> u16 {
                    self.window
                }
            }

            pub struct ConnectionParameters {
                scan_interval : LEScanInterval,
                scan_window : LEScanWindow,
                initiator_filter_policy: InitiatorFilterPolicy,
                peer_address_type: LEAddressType,
                peer_address: ::BluetoothDeviceAddress,
                own_address_type: OwnAddressType,
                connection_interval: ConnectionInterval,
                connection_latency: ConnectionLatency,
                supervision_timeout: SupervisionTimeout,
                connection_event_len: ConnectionEventLength,
            }

            impl CommandParameters for ConnectionParameters {
                type Parameter = le_create_connection_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_CREATE_CONN as u16;
                fn get_parameter(&self) -> Self::Parameter {
                    le_create_connection_cp {
                        interval:            self.scan_interval.get_interval(),
                        window:              self.scan_window.get_window(),
                        initiator_filter:    self.initiator_filter_policy.into_raw(),
                        peer_bdaddr_type:    self.peer_address_type.into_raw(),
                        peer_bdaddr:         bdaddr_t::from(self.peer_address),
                        own_bdaddr_type:     self.own_address_type.into_val(),
                        min_interval:        self.connection_interval.min.get_interval(),
                        max_interval:        self.connection_interval.max.get_interval(),
                        latency:             self.connection_latency.get_latency(),
                        supervision_timeout: self.supervision_timeout.get_timeout(),
                        min_ce_length:       self.connection_event_len.minimum,
                        max_ce_length:       self.connection_event_len.maximum,
                    }
                }
            }

            impl ConnectionParameters {

                /// Command Parameters for connecting without the white list
                pub fn new_without_whitelist(
                    scan_interval : LEScanInterval,
                    scan_window : LEScanWindow,
                    peer_address_type: LEAddressType,
                    peer_address: ::BluetoothDeviceAddress,
                    own_address_type: OwnAddressType,
                    connection_interval: ConnectionInterval,
                    connection_latency: ConnectionLatency,
                    supervision_timeout: SupervisionTimeout,
                    connection_event_len: ConnectionEventLength,
                ) -> Self {
                    Self {
                        scan_interval : scan_interval,
                        scan_window : scan_window,
                        initiator_filter_policy: InitiatorFilterPolicy::DoNotUseWhiteList,
                        peer_address_type : peer_address_type,
                        peer_address : peer_address,
                        own_address_type : own_address_type,
                        connection_interval : connection_interval,
                        connection_latency : connection_latency,
                        supervision_timeout : supervision_timeout,
                        connection_event_len : connection_event_len,
                    }
                }

                /// Command parameters for connecting with the white list
                pub fn new_with_whitelist(
                    scan_interval : LEScanInterval,
                    scan_window : LEScanWindow,
                    own_address_type: OwnAddressType,
                    connection_interval: ConnectionInterval,
                    connection_latency: ConnectionLatency,
                    supervision_timeout: SupervisionTimeout,
                    connection_event_len: ConnectionEventLength,
                ) -> Self {
                    Self {
                        scan_interval : scan_interval,
                        scan_window : scan_window,
                        initiator_filter_policy: InitiatorFilterPolicy::UseWhiteList,
                        peer_address_type : LEAddressType::PublicDeviceAddress, // This is not used (see spec)
                        peer_address : [0u8;6], // This is not used (see spec)
                        own_address_type : own_address_type,
                        connection_interval : connection_interval,
                        connection_latency : connection_latency,
                        supervision_timeout : supervision_timeout,
                        connection_event_len : connection_event_len,
                    }
                }

            }

            pub fn send( hci: &HostInterface, cp: ConnectionParameters ) -> hci_return!() {
                hci.send_command(cp, events::Events::CommandStatus , Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {
                #[test]
                #[ignore]
                fn create_connection_test() {
                    unimplemented!()
                }
            }
        }
        pub mod read_channel_map {
            use bluez::{
                le_read_channel_map_cp,
                le_read_channel_map_rp,
                OCF_LE_READ_CHANNEL_MAP,
                OGF_LE_CTL,
            };
            use hci::*;
            use hci::common::ConnectionHandle;

            pub struct ChannelMapInfo {
                pub handle: ConnectionHandle,
                /// This is the list of channels (from 0 through 36)
                pub channel_map: ::alloc::boxed::Box<[usize]>,
            }

            impl ChannelMapInfo {
                fn try_from(packed: le_read_channel_map_rp) -> Result<Self, error::Error> {
                    use alloc::vec::Vec;

                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {

                        // 37 is the number of channels (as of bluetooth 5.0)
                        let channel_count = 37;

                        let mut count = 0;

                        let mut mapped_channels = Vec::with_capacity(channel_count);

                        'outer: for byte in packed.map.iter() {
                            for bit in 0..8 {
                                if count < channel_count {
                                    if 0 != (byte & (1 << bit)) {
                                        mapped_channels.push(count);
                                        count += 1;
                                    }
                                }
                                else {
                                    break 'outer;
                                }
                            }
                        }

                        Ok( Self {
                            handle: ConnectionHandle::try_from(packed.handle).unwrap(),
                            channel_map: mapped_channels.into_boxed_slice(),
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl CommandParameters for le_read_channel_map_cp {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_CHANNEL_MAP as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_CHANNEL_MAP,
                OGF_LE_CTL,
                le_read_channel_map_rp,
                ChannelMapInfo,
                error::Error
            );

            pub fn send( hci: &HostInterface, handle: ConnectionHandle ) -> hci_return!() {

                let parameter = le_read_channel_map_cp {
                    handle: handle.get_raw_handle()
                };

                hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                #[test]
                #[ignore]
                fn read_channel_map_test() {
                    unimplemented!()
                }
            }
        }
        pub mod read_remote_features {
            use bluez:: {
                read_remote_features_cp,
                OCF_LE_READ_REMOTE_USED_FEATURES,
                OGF_LE_CTL,
            };
            use hci::*;
            use hci::common::ConnectionHandle;

            impl CommandParameters for read_remote_features_cp {
                type Parameter = Self;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_REMOTE_USED_FEATURES as u16;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            pub fn send( hci: HostInterface, handle: ConnectionHandle ) -> hci_return!() {

                let parameter = read_remote_features_cp {
                    handle: handle.get_raw_handle(),
                };

                hci.send_command(parameter, events::Events::CommandStatus, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {
                #[test]
                #[ignore]
                fn read_remote_features_test() {
                    unimplemented!()
                }
            }
        }
        pub mod set_host_channel_classification {
            use bluez::{
                le_set_host_channel_classification_cp,
                OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION,
                OGF_LE_CTL,
            };
            use hci::*;

            const CHANNEL_MAP_MAX: usize = 37;

            pub struct ChannelMap {
                channels: [bool;CHANNEL_MAP_MAX]
            }

            impl ChannelMap {
                pub const MAX: usize = 37;

                /// try to create a Channel Map
                ///
                /// This will form a channel map so long as every value in slice referenced by
                /// channels is less then CHANNEL_MAP_MAX
                ///
                /// # Error
                /// A value in the parameter was found to be larger then CHANNEL_MAP_MAX
                pub fn try_from<'a>(channels: &'a[usize]) -> Result<Self, usize> {

                    let mut channel_flags = [false;CHANNEL_MAP_MAX];

                    for val in channels {
                        if *val < CHANNEL_MAP_MAX {
                            channel_flags[*val] = true;
                        }
                        else {
                            return Err(*val);
                        }
                    }

                    Ok( Self {
                        channels: channel_flags
                    })
                }
            }

            impl CommandParameters for ChannelMap {
                type Parameter = le_set_host_channel_classification_cp;
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION as u16;
                fn get_parameter(&self) -> Self::Parameter {

                    let mut raw = [0u8;5];

                    for val in 0..CHANNEL_MAP_MAX {
                        if self.channels[val] {
                            raw[val / 8] |= 1 << (val % 8)
                        }
                    }

                    le_set_host_channel_classification_cp {
                        map : raw
                    }
                }
            }

            impl_status_return!(OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION, OGF_LE_CTL);

            pub fn send( hci: HostInterface, map: ChannelMap ) -> hci_return!() {
                hci.send_command( map, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod test {

                use super::*;

                #[test]
                #[ignore]
                fn set_host_channel_classification_test() {
                    unimplemented!()
                }

                #[test]
                fn channel_map_test() {
                    unimplemented!();
                    let expected_raw_map = [
                        (1 << 3) | (1 << 7),
                        (1 << (9 - 8)) | (1 << (11 - 8)) | (1 << (13 - 8)),
                        0,
                        0,
                        0,
                    ];

                    let map = ChannelMap::try_from(&[11,11,3,9,13,7]).unwrap();
                }
            }
        }
        #[cfg(bluetooth_5_0)]
        pub mod read_transmit_power_level {
            use bluez::OGF_LE_CTL;
            use hci::*;
            use std::ops::RangeInclusive;

            const OCF_LE_READ_TRANSMIT_POWER: u16 = 0x4B;

            #[repr(packed)]
            struct PackedReturn {
                status: u8,
                min_tx_power: u8,
                max_tx_power: u8,
            }

            /// Transmit power range (from minimum to maximum levels)
            pub struct TransmitPowerRange {
                min: u8,
                max: u8,
            }

            impl TransmitPowerRange {

                pub fn into_range_inclusive(&self) -> RangeInclusive<u8> {
                    self.min..=self.max
                }

                pub fn minimum_transmit_power(&self) -> u8 {
                    self.min
                }

                pub fn maximum_transmit_power(&self) -> u8 {
                    self.max
                }

                fn try_from(packed: PackedReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(Self {
                            min: packed.min_tx_power,
                            max: packed.max_tx_power,
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_LE_READ_TRANSMIT_POWER,
                OGF_LE_CTL,
                PackedReturn,
                TransmitPowerRange,
                error::Error
            );

            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = ();
                const OGF: u16 = OGF_LE_CTL as u16;
                const OCF: u16 = OCF_LE_READ_TRANSMIT_POWER;
                fn get_parameter(&self) -> Self::Parameter {()}
            }

            pub fn send( hci: HostInterface ) -> hci_return!() {
                hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {
                use super::*;
                use hci::test_util::block_for_command_result;

                #[test]
                fn read_transmit_power_level() {
                    let result = block_for_command_result!(
                        send(&HostInterface::default()).unwrap()
                    )
                    .unwrap();

                    assert_eq!(result.len(), 1);

                    command_complete_test!(result[0], TransmitPowerRange);
                }
            }
        }
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod read_remote_version_information {
            use bluez::{
                read_remote_version_cp,
                OGF_LINK_CTL,
                OCF_READ_REMOTE_VERSION,
            };
            use hci::*;
            use hci::common::ConnectionHandle;

            impl CommandParameters for read_remote_version_cp {
                type Parameter = Self;
                const OGF: u16 = OGF_LINK_CTL as u16;
                const OCF: u16 = OCF_READ_REMOTE_VERSION as u16;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface, handle: ConnectionHandle) -> hci_return!() {

                let parameter = read_remote_version_cp {
                    handle: handle.get_raw_handle()
                };

                hci.send_command(parameter, events::Events::CommandStatus, Duration::from_secs(1) )
            }

            #[cfg(test)]
            mod tests {

                #[test]
                #[ignore]
                fn read_remote_version_information_test() {
                    unimplemented!()
                }
            }
        }
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod read_rssi {
            use bluez:: {
                read_rssi_rp,
                OGF_STATUS_PARAM,
                OCF_READ_RSSI,
            };
            use hci::*;
            use hci::common::ConnectionHandle;

            struct Parameter {
                handle: u16
            }

            impl CommandParameters for Parameter {
                type Parameter = u16;
                const OGF: u16 = OGF_STATUS_PARAM as u16;
                const OCF: u16 = OCF_READ_RSSI as u16;
                fn get_parameter(&self) -> Self::Parameter { self.handle }
            }

            pub struct RSSIInfo {
                pub handle: ConnectionHandle,
                pub rssi: i8
            }

            impl RSSIInfo {
                fn try_from(packed: read_rssi_rp) -> Result<Self, error::Error > {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok( Self {
                            handle: ConnectionHandle::try_from(packed.handle).unwrap(),
                            rssi: packed.rssi
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                OCF_READ_RSSI,
                OGF_STATUS_PARAM,
                read_rssi_rp,
                RSSIInfo,
                error::Error
            );

            pub fn send( hci: &HostInterface, handle: ConnectionHandle ) -> hci_return!() {
                let parameter = Parameter {
                    handle: handle.get_raw_handle()
                };

                hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) )
            }
        }
    }
//
//     pub mod br_edr {
//         // TODO does this module make sense?
//         pub mod support {
//             pub fn read_le_host() { unimplemented!() }
//             pub fn write_le_host() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn read_buffer_size() { unimplemented!() }
//         }
//     }
//
//     pub mod scannable {
//         pub mod command {
//             pub fn set_scan_response_data() { unimplemented!() }
//         }
//     }
//
//     pub mod encryption {
//         pub mod event {
//             pub fn encryption_change() { unimplemented!() }
//             pub fn encryption_key_refresh_complete() { unimplemented!() }
//             pub fn long_term_key_request() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn encrypt() { unimplemented!() }
//             pub fn long_term_key_request_reply() { unimplemented!() }
//             pub fn long_term_key_request_negative_reply() { unimplemented!() }
//             pub fn rand() {unimplemented!()}
//             pub fn start_encryption() { unimplemented!() }
//         }
//     }
//
//     pub mod connection_parameters_request_procedure {
//         pub mod event {
//             pub fn remote_connection_paramter_request() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn remote_connection_parameter_request_reply() { unimplemented!() }
//             pub fn remote_connection_parameter_request_negative_reply() { unimplemented!() }
//         }
//     }
//
//     pub mod ping {
//         pub mod event {
//             pub fn authenticated_payload_timeout_expired() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn write_authenticated_payload_timeout() { unimplemented!() }
//             pub fn read_authenticated_payload_timeout() { unimplemented!() }
//             pub fn set_event_mask_page_2() { unimplemented!() }
//         }
//     }
//
//     pub mod data_packet_length_extension {
//         pub mod event {
//             pub fn data_length_change() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_data_length() { unimplemented!() }
//             pub fn read_suggested_default_data_length() { unimplemented!() }
//             pub fn write_suggested_default_data_length() { unimplemented!() }
//         }
//     }
//
//     pub mod privacy {
//         pub mod event {
//             pub fn directed_advertising_report() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_resolvable_private_address_timeout() { unimplemented!() }
//             pub fn set_address_resolution_enable() { unimplemented!() }
//             pub fn add_device_to_resolving_list() { unimplemented!() }
//             pub fn clear_resolving_list() { unimplemented!() }
//             pub fn set_privacy_mode() { unimplemented!() }
//             pub fn read_peer_resolvable_address() { unimplemented!() }
//             pub fn read_local_resolvable_address() { unimplemented!() }
//         }
//     }
//
//     pub mod phy_2m_or_coded {
//         pub mod event {
//             pub fn phy_update_complete() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn read_phy() { unimplemented!() }
//             pub fn set_default_phy() { unimplemented!() }
//             pub fn set_phy() { unimplemented!() }
//             pub fn enhanced_transmitter_test() { unimplemented!() }
//             pub fn enhanced_receiver_test() { unimplemented!() }
//         }
//     }
//
//     pub mod extended_advertising {
//         pub mod event {
//             pub fn scan_request_received() { unimplemented!() }
//             pub fn advertising_set_terminated() { unimplemented!() }
//             pub fn scan_timeout() { unimplemented!() }
//             pub fn extended_advertising_report() { unimplemented!() }
//         }
//         pub mod legacy_event {
//             /// Superseded by extended_advertising_report
//             pub fn advertising_report() { unimplemented!() }
//             /// Superseded by exted_advertising_report
//             pub fn direted_advertising_report() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_advertising_set_random_address() { unimplemented!() }
//             pub fn set_extended_advertising_parameters() { unimplemented!() }
//             pub fn set_extended_advertising_data() { unimplemented!() }
//             pub fn set_extended_scan_response_data() { unimplemented!() }
//             pub fn set_extended_advertising_enable() { unimplemented!() }
//             pub fn read_maximum_advertising_data_length() { unimplemented!() }
//             pub fn read_number_of_supported_advertising_sets() { unimplemented!() }
//             pub fn remove_advertising_set() { unimplemented!() }
//             pub fn clear_advertisisng_sets() { unimplemented!() }
//             pub fn set_extended_scan_parameters() { unimplemented!() }
//             pub fn set_extended_scan_enable() { unimplemented!() }
//             pub fn extended_create_connection() { unimplemented!() }
//         }
//         pub mod legacy_command {
//             /// Superseded by set_extended_advertising_parameters
//             pub fn set_advertising_parameters() { unimplemented!() }
//             /// No longer used
//             pub fn read_advertising_channel_tx_power() { unimplemented!() }
//             /// Superseded by set_extended_advertising_data
//             pub fn set_advertising_data() { unimplemented!() }
//             /// Superseded by set_extended_advertising_enable
//             pub fn set_scan_parameters() { unimplemented!() }
//             /// Superseded by set_extended_scan_enable
//             pub fn set_scan_enable() { unimplemented!() }
//             /// Superseded by extended_create_connection
//             pub fn extended_create_connection() { unimplemented!() }
//         }
//     }
//
//     pub mod periodic_advertising {
//         pub mod event {
//             pub fn periodic_advertising_report() { unimplemented!() }
//             pub fn periodic_advertising_sync_established() { unimplemented!() }
//             pub fn periodic_advertising_sync_lost() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_periodic_advertising_parameters() { unimplemented!() }
//             pub fn set_periodic_advertising_data() { unimplemented!() }
//             pub fn set_periodic_advertising_enable() { unimplemented!() }
//             pub fn periodic_advertising_create_sync() { unimplemented!() }
//             pub fn periodic_advertising_create_sync_cancel() { unimplemented!() }
//             pub fn periodic_advertising_terminate_sync() { unimplemented!() }
//             pub fn add_device_to_periodic_advertising_list() { unimplemented!() }
//             pub fn remove_device_from_periodic_advertiser_list() { unimplemented!() }
//             pub fn clear_periodic_advertiser_list() { unimplemented!() }
//             pub fn read_periodic_advertiser_list_size() { unimplemented!() }
//         }
//     }
//
//     pub mod advertising_of_tx_power {
//         pub mod command {
//             pub fn read_rf_path_compensation() { unimplemented!() }
//             pub fn write_rf_path_compensation() { unimplemented!() }
//         }
//     }
//
//     pub mod channel_selection_algorithm_2 {
//         pub mod event {
//             pub fn chennel_selection_algorithm() { unimplemented!() }
//         }
//     }
//
//     pub mod other {
//         pub mod event {
//             pub fn data_buffer_overflow() { unimplemented!() }
//             pub fn hardware_error() { unimplemented!() }
//             pub fn read_local_p256_public_key_complete() { unimplemented!() }
//             pub fn generate_dh_key_complete() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn host_buffer_size() { unimplemented!() }
//             pub fn host_number_of_completed_packets() { unimplemented!() }
//             pub fn le_read_transmit_power() { unimplemented!() }
//             pub fn le_read_p256_public_key() { unimplemented!() }
//             pub fn generate_dh_key() { unimplemented!() }
//         }
//     }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn host_interface_default_test() {
        HostInterface::default();
    }
}
