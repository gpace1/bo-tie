//! LE Privacy
//!
//! Privacy is a way for two devices to reconnect and re-encrypt without having to go through
//! pairing. When two devices are in a non-connected state, they will use resolvable private
//! addresses to determine what devices to connect to. A resolvable private address requires an
//! identity resolving key to *resolve*, and in doing so authenticate the identity of a connecting
//! or advertising device.
//!
//! There is two major ways to perform privacy in a peripheral. The most common way is to utilize
//! the resolvable private in the Bluetooth Controller to only generate HCI connection events for
//! private address that are successfully resolved. The other way is to have the host perform
//! resolving on all connections and disconnect those whose addresses are not a resolvable private
//! address or do not resolve.
//!
//! ## Controller Implemented Privacy
//! Using the Bluetooth Controller is the easiest way to setup and use Privacy, but the hardware
//! needs to support the LE Privacy feature. For the most part this is not a problem as most LE
//! supported Controllers. The HCI command *[LE Read Local Supported Features]* can be used to check
//! if the Controller supports the feature. The most likely reason for not having LE Privacy is that
//! device was grandfathered from Bluetooth 4.0 (or is a 4.0 or 4.1 device). Lots of devices say
//! they are 5.X compliant whereby they were a 4.0 chip that met the minimum requirements for
//! compliance of 5.X or greater versions of Bluetooth (Privacy as a Controller feature was added in
//! Bluetooth version 4.2).   
//!
//! Setting up the Controller to enable privacy requires the minimum of the commands
//! [LE Add Device To Resolving List] and [LE Set Address Resolution Enable Command]. The device
//! must also be added to the filter list with the command [LE Add Device To Filter List]. Then a
//! LE connect HCI command can be issued to the controller. When a connectible advertisement is
//! received and it contains a resolvable private address, the resolving list will check to see if
//! any entries within it contain an identity resolving key that can resolve the address. If a key
//! found that can resolve the address, then the peer identity address associated with the key is
//! checked to be within the filter list. If it is in the filter list then the Controller will
//! initiate a connection to the advertising device.
//!
//! #### Note
//! It is recommended to limit the number of resolving entries within the resolving list to the
//! minimum number of devices that are to be reconnected. Everytime an advertisement with a
//! resolvable private address is received, all entries must be run through to check if the address
//! can be resolved by any of the identity resolving keys.
//!
//! ## Host Implement Privacy
//! When the host implements privacy, the resolving list is stored and managed by the host. Instead
//! of calling a LE connect HCI command, the host enables scanning and performs the validation of
//! resolvable private addresses itself. When a device can be resolved the host will set the random
//! address to a resolvable private address generated by a local identity resolving key and then
//! call a LE connect HCI command.
//!
//! The host must maintain a resolving list similar to the resolving list that would have been
//! implemented in the Controller. Everytime a resolvable private address is received in a scan
//! record, all entries within the list (that are desired to establish a connection) must be run
//! through to check if the identity resolving key within the entry can resolve the address. Each
//! entry should contain at least the identity resolving key and identity address of the peer
//! device. If unique identity resolving keys are provided to each bonded device (such as in this
//! example), these unique identity keys must also be stored within the entry. It may also be
//! helpful to add a boolean to to the entry to indicate if the device is already connected.
//!
//! This example will only ever connect to a single device, so the resolving list only contains a
//! single entry.
//!
//! ### Resolving
//! A resolvable private address has two parts. The first half of the address is called a `prand`
//! and the last half is the `hash`. `prand` is randomly generated but the `hash` is generated using
//! an identity resolving key and the [`ah`] function. The peer device will use the same identity
//! resolving key to check if the `hash` was generated from the `prand` in the address. This
//! authenticates the address and the central device can then use a previously generated long term
//! key to initiate encryption.
//!
//! As part of bonding both devices must transfer their identity resolving key. This means that both
//! devices hold on to two keys, the peer key and their key. What key is used for creating a
//! resolvable private key depends on what kind of advertising is used by the peripheral device.
//! This is specification defined under the Privacy section of the Link Layer Specification of the
//! Low Energy Controller (Vol 6, Part B, Section 6).
//!
//! [`ah`]: bo_tie::host::sm::toolbox::ah
//! [LE Read Local Supported Features]: bo_tie::hci::commands::le::read_local_supported_features
//! [LE Add Device To Resolving List]: bo_tie::hci::commands::le::add_device_to_resolving_list
//! [LE Add Device To Filter List]: bo_tie::hci::commands::le::add_device_to_filter_list
//! [`b`]: bo_tie::hci::commands::le::remove_device_from_resolving_list

mod controller_privacy;
pub mod host_privacy;

use bo_tie::hci::{Connection, Host, HostChannelEnds};
use bo_tie::host::sm::Keys;
use bo_tie::LeFeatures;

enum PrivacyMode {
    Controller(controller_privacy::Controller),
    Host(host_privacy::HostPrivacy),
}

/// Structure for using Privacy for the selected Controller
///
/// This combines both the Controller Privacy and Host Privacy routines into one type. Controller
/// privacy is always preferred over Host implemented privacy if the Controller supports the feature
/// LE Privacy.
///
/// `Privacy` has two "modes", *controller* and *host*. In *Controller* mode the Bluetooth
/// Controller performs the generation and resolving of resolvable private addresses. In *host* mode
/// this example will do the generation and resolving of resolvable private addresses. The mode is
/// determined by checking if the Bluetooth Controller has the LE feature `LL Privacy`. If it does
/// then *controller* is set as the mode, but if it does not then the mode is *host*.
pub struct Privacy {
    mode: PrivacyMode,
}

impl Privacy {
    /// Create a new `Privacy`
    ///
    /// This first queries the Controller for the LE local features to determine if `LL Privacy` is
    /// available in the controller, then a `Privacy` is created`.
    pub async fn new<H: HostChannelEnds>(host: &mut Host<H>) -> Self {
        use bo_tie::hci::commands::le::read_local_supported_features;

        let features = read_local_supported_features::send(host).await.unwrap();

        let has_privacy_feature = features.iter().any(|feature| feature == LeFeatures::LlPrivacy);

        let mode = if has_privacy_feature {
            PrivacyMode::Controller(controller_privacy::Controller::new())
        } else {
            PrivacyMode::Host(host_privacy::HostPrivacy::new())
        };

        Self { mode }
    }

    /// Add a device to the resolving list
    ///
    /// # Note
    /// For simplifying this example, this also adds the device to the whitelist.
    pub async fn add_device_to_resolving_list<H: HostChannelEnds>(&mut self, host: &mut Host<H>, keys: &Keys) {
        match &mut self.mode {
            PrivacyMode::Controller(c) => c.add_device_resolving_list(host, keys).await,
            PrivacyMode::Host(h) => h.add_to_resolving_list(keys),
        }
    }

    /// Clear all devices from the resolving list
    ///
    /// # Note
    /// For simplifying this example, this also clears the whitelist.
    pub async fn clear_resolving_list<H: HostChannelEnds>(&mut self, host: &mut Host<H>) {
        match &mut self.mode {
            PrivacyMode::Controller(_) => controller_privacy::Controller::clear_resolving_list(host).await,
            PrivacyMode::Host(h) => h.clear_resolving_list(),
        }
    }

    /// Reconnect to the Bonded Device.
    ///
    /// When the peer device begins advertising (with a resolvable private address), this will
    /// automatically reconnect to it once it receives an advertisement from it.
    pub async fn reconnect<H: HostChannelEnds>(&mut self, host: &mut Host<H>) -> Connection<H::ConnectionChannelEnds> {
        match &mut self.mode {
            PrivacyMode::Controller(_) => controller_privacy::Controller::reconnect(host).await,
            PrivacyMode::Host(h) => h.reconnect(host).await,
        }
    }
}
